/** MIT License

    Copyright (c) 2021 Zhe Deng

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

/** Title: VA (https://github.com/thezhe/SOUL-VA)

    Virtual analog library -- a collection of mostly novel nonlinear filters. Interface based on
    soul::filters (https://github.com/soul-lang/SOUL/blob/master/source/soul_library/soul_library_filters.soul).

    This library's structure is nearly identical to soul::filters EXCEPT:
    - 'Processors' under 'VA::HighLevel' are standalone effects  
    - Default 'SampleType' is float64
    - Default updateInterval is 32
    - 'CoeffType' is not defined ('SampleType' is used internally for coefficients and samples)
    - SIMD-style bit masking is supported (see Sample-Agnostic Utilities)
    - 'Processors' are optimized for 44.1kHz/24-bit with specific recommendations for under/oversampling

    Note:
    - soul.exe has limited support for the primitive type float64. Compile to cpp or test on the playground on soul.dev
*/

namespace VA (using SampleType = float64, int updateInterval = 32)
{
/*==============================================================================
Constants
==============================================================================*/
    
    //==============================================================================
    static_assert (SampleType.primitiveType.isFloat, "Primitive type of 'SampleType' must be float32 or float64");
    static_assert ((SampleType.isVector || SampleType.isFloat), "'SampleType' must be float32, float64, or a vector of float64/float32");
    static_assert (updateInterval > 0, "'updateInterval' must be greater than 0");

    //==============================================================================
    let SIMD = bool (SampleType.isVector);

    //==============================================================================
    let N100dB = float (0.00001);
    let ADAA_TOL = SampleType (0.0000001);
    let inf32 = float (inf);

/*==============================================================================
SampleType-Agnostic Utilities
==============================================================================*/

    //==============================================================================
    /** 'if' statement that supports vector and scalar inputs
    
        Not necessarily faster with vectors; use conservatively!
    */
    SampleType vif<BoolType> (SampleType trueStatement, SampleType falseStatement, BoolType condition)
    {   
        if (SIMD)
        {
            return trueStatement * SampleType (condition) + falseStatement * SampleType (!condition);
        }
        else
        {
            if (condition)
                return trueStatement;
            else
                return falseStatement;
        }
    }

    //==============================================================================
    /** clamp a value between low and high

        If 'low' = inf32 or 'high' = inf32, they will be optimized out at compile time
    */
    namespace vclamp (float low = -inf32, float high = inf32)
    {       
        let l = SampleType (low);
        let h = SampleType (high);

        SampleType process (SampleType x)
        {
            if const (SIMD)
            {
                if const (low > -inf32 && high < inf32)
                    return vif (vif (x, l, x > l), h, x < h); 
                else if const (low > -inf32)
                    return vif (x, l, x > l);
                else
                    return vif (x, h, x < h);
            }
            else
            {
                if const (low > -inf32 && high < inf32)
                    return clamp(x, l, h);
                else if const (low > -inf32)
                    return max (x, l);
                else
                    return min (x, h);           
            }
        }
        processor Processor ()
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << process (in);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** Convert gain to decibels and clamp results to greater than -100.0 dB */
    SampleType vgainTodB (SampleType x)
    {
        if (SIMD)
        {
            let temp = vclamp (N100dB, inf)::process(x);

            return SampleType (20.0) * log10 (temp);
        }
        else
        {
            if (x < N100dB)
                return SampleType (-100.0);
            
            return SampleType (20.0) * log10 (x);
        }
    }

    //==============================================================================
    /** Convert decibels to gain and clamp inputs to greater than -100.0 dB */
    SampleType vdBtoGain (SampleType x)
    {
        if (SIMD)
        {
            let temp = vclamp (-100, inf)::process(x);

            return pow (SampleType (10.0), temp / SampleType (20.0));
        }
        else
        {
            if (x < SampleType (-100.0))
                return N100dB;
            
            return pow (SampleType (10.0), x / SampleType (20.0));
        }
    }

    //==============================================================================
    /** Return 1 if x is positive, -1 if negative, and 0 otherwise */
    SampleType vsgn (SampleType x)
    {
        return SampleType(x > SampleType (0.0)) - SampleType(x < SampleType (0.0));
    }

    //==============================================================================
    SampleType vabs (SampleType x)
    {
        if const (SIMD)
        {
            SampleType temp;

            for (wrap<SampleType.size> i)
                temp[i] = abs (x[i]);
            
            return temp;
        }
        else 
            return abs (x);
    }

    //==============================================================================
    /** Set a vector equal to the average of its elements. 
    
        Do not use on scalar 'SampleTypes'!
    */
    namespace StereoLink
    {   
        struct Coeffs
        {
            bool e; //enabled
        }
    
        void update (Coeffs& c, float enabled)
        {
            c.e = bool (enabled);
        }
    
        SampleType process (SampleType x, Coeffs& c)
        {
            if (SIMD)
                return (c.e ? SampleType (x.sum()/x.size) : x);
            else 
                return SampleType (0.0);
        }
    
        processor Processor (bool initialEnabled = true)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event float enabledIn [[ name: "Enabled", min: 0, max: 1, init: float (initialEnabled), unit: "Off|On" ]];
            
            event enabledIn (float v) { enabled = v; recalc = true; }

            float enabled = float (initialEnabled);
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;
    
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (enabled);
                    }
    
                    loop (updateInterval)
                    {
                        out << process (in, c);
    
                        advance();
                    }
                }
            }
        }
    }
    
    //==============================================================================
    /** An algebraic sigmoid function. 

            f(x) = x / sqrt (1 + x^2) 
    
        A cheap approximation of 'tanh'
    */
    SampleType vsigmoid (SampleType x)
    {
        return x / sqrt (SampleType (1.0) + x * x);
    }

    //==============================================================================
    /** A differentiable algebraic approximation of 'abs'. */
    SampleType vabsApprox (SampleType x)
    {
        return x * vsigmoid (SampleType (5.0) * x);
    }

    //==============================================================================
    /** 'Processor' wrapper of 'vabs' 
    
        See Sample-Agnostic Utility Functions
    */
    namespace Abs
    {
        processor Processor()
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << vabs (in);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    namespace Multiply
    {
        processor Processor()
        {
            input stream SampleType in1, in2;
            output stream SampleType out;
    
            void run()
            {
                loop
                {
                    out << in1 * in2;
    
                    advance();
                }
            }
        }
    }

    //==============================================================================
    namespace Reciprocal
    {
        processor Processor()
        {
            input stream SampleType in;
            output stream SampleType out;
    
            void run()
            {
                loop
                {
                    out << SampleType (1.0) / in;
    
                    advance();
                }
            }
        }
    }

    //==============================================================================
    namespace OmegaTog
    {
        processor Processor()
        {
            input stream SampleType Omega;
            output stream SampleType g;
    
            void run()
            {
                let Tdiv2 = SampleType (processor.period * 0.5);

                loop
                {
                    g << Omega * Tdiv2;
    
                    advance();
                }
            }
        }
    }

/*==============================================================================
Effect Components
==============================================================================*/

    //==============================================================================
    /** soul::filters::tpt::onepole modified for cutoff modulation via an input stream

        See oversampling reccomendation in endpoint comments
    */
    namespace Onepole
    {   
        struct Coeffs
        {
            SampleType G;
        }

        struct State
        {
            SampleType s;
        }

        SampleType[2] process (State& s, SampleType x, Coeffs& c)
        {
            let vn = (x - s.s) * c.G;
            let lpf = vn + s.s;
            s.z1 = vn + lpf;
            let hpf = x - lpf;
            return SampleType[2] (lpf, hpf);
        }

        void update (Coeffs& c, float frequency)
        {
            let g = float (twoPi) * frequency;
            c.G = SampleType (g / (1.f + g));
        }

        processor Processor (float initialFrequency, int cutoffMode = 0)
        {
            input stream SampleType in;
            output stream SampleType lowpassOut, highpassOut;

            input event float modeIn [[ name: "Frequency", min: 20, max: 20000, init: initialFrequency, text: "Hz" ]];

            event modeIn (float v) { mode = v; recalc = true; }

            float mode = float (initialMode);

            bool recalc = true;
            void run()
            {   
                State s;
                Coeffs c;

                let Tdiv2 = SampleType (processor.period * 0.5);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;


                    }

                    loop (updateInterval)
                    {
                        let y = s.process (in, c);

                        lowpassOut << y[0];
                        highpassOut << y[1];

                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /** soul::filters::tpt::onepole modified for cutoff modulation via an input stream

        See oversampling reccomendation in endpoint comments
    */
    namespace OnepoleC
    {   
        processor Processor (int cutoffMode = 0)
        {
            input stream SampleType in;
            input stream SampleType Omega; //angular cutoff; must be > 0; oversample x2; use for any cutoffs
            input stream SampleType g; //integrator input gain; do not oversample; use for low cutoffs
            output stream SampleType lowpassOut, highpassOut;

            void run()
            {   
                Onepole::State s;
                Onepole::Coeffs c;

                let Tdiv2 = SampleType (processor.period * 0.5);

                loop
                {
                    if const (cutoffMode == 0)
                    {
                        let temp = Omega * Tdiv2; 
                        c.G = temp / (SampleType (1.0) + temp);
                    }
                    else 
                        c.G = g / (SampleType (1.0) + g);

                    let y = Onepole::process (s, in, c);

                    lowpassOut << y[0];
                    highpassOut << y[1];

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** soul::filters::tpt::onepole modified for state variable saturation */
    namespace OnepoleS
    {   
        SampleType[2] process (Onepole::State& s, SampleType x, Onepole::Coeffs& c)
        {
            let vn = (x - s.s) * c.G;
            let lpf = vn + s.s;
            let hpf = x - lpf;

            s.s = vsigmoid (vn + lpf);
            return SampleType[2] (lpf, hpf);
        }

        processor Processor (float initialFrequency)
        {
            input stream SampleType in;
            output stream SampleType lowpassOut, highpassOut;

            void run()
            {   
                State s;
                Coeffs c;

                let Tdiv2 = SampleType (processor.period * 0.5);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;


                    }

                    loop (updateInterval)
                    {
                        let y = s.process (in, c);

                        lowpassOut << y[0];
                        highpassOut << y[1];

                        advance();
                    }
                }
            }
        }
    }
    
    //==============================================================================
    /** soul::tpt::svf modified for cutoff/resonance modulation via input streams
    
        2x oversampling recommended
    */  
    namespace SVF
    {
        struct Coeffs
        {
            SampleType a0;
            SampleType a;
            SampleType p;
        }

        struct State
        {
            SampleType[2] z;
        }

        void reset (State& s)
        {
            s.z[0] = SampleType();
            s.z[1] = SampleType();
        }

        SampleType[3] process (State& s, SampleType x, Coeffs& c)
        {
            let hpf = c.a0 * (x - c.p * s.z[0] - s.z[1]);
            let bpf = c.a * hpf + s.z[0];
            let lpf = c.a * bpf + s.z[1];

            s.z[0] = c.a * hpf + bpf;
            s.z[1] = c.a * bpf + lpf;

            return SampleType[3] (lpf, hpf, bpf);
        }

        processor Processor()
        {
            input stream SampleType in;
            input stream SampleType Omega; //angular cutoff; must be > 0
            input stream SampleType R; //resonance; must be > 0
            output stream SampleType lowpassOut, highpassOut, bandpassOut;

            void run()
            {
                State s;
                Coeffs c;

                let Tdiv2 = SampleType (processor.period * 0.5); 

                loop
                {
                    c.a = Omega * Tdiv2; //g
                    c.a0 = SampleType (1.0) / (SampleType (1.0) + SampleType (2.0) * R * c.a + c.a * c.a); //d
                    c.p = SampleType (2.0) * R + c.a; //g1

                    let y = s.process(in, c);

                    lowpassOut  << y[0];
                    highpassOut << y[1];
                    bandpassOut << y[2];
                    
                    advance();
                }
            }
        }
    }



    //==============================================================================
    /** Anhysteretic inductance (Lan).

        Omega = (N * |in| + c) ^ 2

        Based on the Froehlich-Kennelley model.
        https://www.dafx.de/paper-archive/2015/DAFx-15_submission_68.pdf
    */
    namespace Lan
    {
        struct Coeffs
        {
            SampleType c; //depends on freqHz
            SampleType N; //nonlinearity
        }

        void update (Coeffs& c, float frequency, float nonlinearity)
        {
            c.c = sqrt (SampleType (twoPi) * SampleType (frequency));
            c.N = SampleType (nonlinearity);
        }

        SampleType process(SampleType x, Coeffs& c)
        {
            let temp = c.N * vabs (x) + c.c;

            return temp * temp;
        }
        
        processor Processor(float initialFrequency = 0,
                            float initialNonlinearity = 10)
        {
            input stream SampleType in;
            output stream SampleType Omega;
            
            input event
            {
                float frequencyIn [[ name: "Frequency", min: 20, max: 18000, init: initialFrequency, unit: "Hz" ]];
                float nonlinearityIn [[ name: "Nonlinearity", min: 0, max: 100, init: initialNonlinearity ]];
            }

            event frequencyIn (float v) { frequency = v; recalc = true; }
            event nonlinearityIn (float v) { nonlinearity = v; recalc = true; }

            float frequency = initialFrequency;
            float nonlinearity = initialNonlinearity;
            bool recalc = true;

            void run()
            {
                Coeffs c;

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (frequency, nonlinearity);
                    }

                    loop (updateInterval)
                    {   
                        Omega << process(in, c);

                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /** 'Lan' with second-order antiderivative antialiasing
    
        Warning: ONLY use with 'float64' samples.
        2x oversampling recommended.
    */
    namespace LanADAA2
    {   
        struct Coeffs
        {
            //f
            Lan::Coeffs lanCoeffs;
            //F1
            SampleType cSq; //c*c
            SampleType cN;
            SampleType NSqDiv3; 
            //F2
            SampleType NSqDiv12;
            SampleType cNDiv3;
            SampleType cSqDiv2;
        }
    
        struct State
        {
            SampleType x_2;
            SampleType x_1;
            SampleType F2_1;
            SampleType F1_1;
        }
    
        void reset (State& s)
        {
            s.x_2 = SampleType();
            s.x_1 = SampleType();
            s.F2_1 = SampleType();
            s.F1_1 = SampleType(); 
        }
    
        void update (Coeffs& c, float frequency, float nonlinearity)
        {
            c.lanCoeffs.c = sqrt (SampleType (twoPi) * SampleType (frequency));
            c.lanCoeffs.N = SampleType (nonlinearity);
            
            c.cSq = c.lanCoeffs.c * c.lanCoeffs.c;
            c.cN = c.lanCoeffs.c * c.lanCoeffs.N;
            c.NSqDiv3 = (c.lanCoeffs.N * c.lanCoeffs.N) / SampleType (3.0);
        
            c.cSqDiv2 = c.cSq / SampleType (2.0);
            c.cNDiv3 = c.cN / SampleType (3.0);
            c.NSqDiv12 = c.NSqDiv3 / SampleType (4.0);
        }
        
        SampleType F2 (SampleType x, Coeffs& c)
        {
            let xSq = x * x;
            return xSq * (c.cSqDiv2 + c.cNDiv3 * x * vsgn(x) + c.NSqDiv12 * xSq);
        }
    
        SampleType F1 (SampleType x, Coeffs& c)
        {
            let xSq = x * x;
            let xCb = xSq * x;
            return c.cSq * x + c.cN * xSq * vsgn(x) + c.NSqDiv3 * xCb;   
        }
    
        SampleType f (SampleType x, Coeffs& c)
        {
            return Lan::process (x, c.lanCoeffs);
        }
    
        SampleType process (State& s, SampleType x, Coeffs& c)
        {
            //Find F1_0
            SampleType F1_0;
            
            let x_0mx_1 = x - s.x_1;
            let F2_0 = F2 (x, c);

            if const (SIMD)
            {
                F1_0 = vif (F1 (SampleType (0.5) * (x + s.x_1), c), 
                    (F2_0 - s.F2_1) / x_0mx_1,
                    vabs (x_0mx_1) < ADAA_TOL);
            }
            else
            {
                if (vabs (x_0mx_1) < ADAA_TOL)
                    F1_0 = F1 (SampleType (0.5) * (x + s.x_1), c);
                else
                    F1_0 = (F2_0 - s.F2_1) / x_0mx_1;
            }

            //Find f_0
            SampleType f_0;
            let x_0mx_2 = x - s.x_2;

            if const (SIMD)
            {
                let xBar = SampleType (0.5) * (x + s.x_2);
                let delta = xBar - x;

                let trueStatement = vif(F1 (SampleType (0.5) * (xBar + x), c),
                    (SampleType (2.0) / delta) * (F1 (xBar, c) + (F2_0 - F2 (xBar, c)) / delta),
                    vabs (delta) < ADAA_TOL);

                f_0 = vif (trueStatement, 
                    (SampleType (2.0) / (x_0mx_2)) * (F1_0 - s.F1_1), 
                    vabs (x_0mx_2) < ADAA_TOL);
            }
            else
            {
                if (vabs (x_0mx_2) < ADAA_TOL)
                {
                    let xBar = SampleType (0.5) * (x + s.x_2);
                    let delta = xBar - x;
        
                    if (vabs (delta) < ADAA_TOL)
                        f_0 = F1 (SampleType (0.5) * (xBar + x), c);
                    else
                        f_0 = (SampleType (2.0) / delta) * (F1 (xBar, c) + (F2_0 - F2 (xBar, c)) / delta);
                }
                else
                    f_0 = (SampleType (2.0) / (x_0mx_2)) * (F1_0 - s.F1_1);
            }

            //update s
            s.x_2 = s.x_1;
            s.x_1 = x;
            s.F2_1 = F2_0;
            s.F1_1 = F1_0;
    
            return f_0;
        }
    
        processor Processor(float initialFrequency = 0, float initialNonlinearity = 10)
        {
            input stream SampleType in;
            output stream SampleType Omega;
            
            input event
            {
                float frequencyIn [[ name: "Frequency", min: 20, max: 18000, init: initialFrequency, unit: "Hz" ]];
                float nonlinearityIn [[ name: "Nonlinearity", min: 0, max: 100, init: initialNonlinearity ]];
            }

            event frequencyIn (float v) { frequency = v; recalc = true; }
            event nonlinearityIn (float v) { nonlinearity = v; recalc = true; }

            float frequency = initialFrequency;
            float nonlinearity = initialNonlinearity;
            bool recalc = true;

            void run()
            {
                State s;
                Coeffs c;

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (frequency, nonlinearity);
                    }

                    loop (updateInterval)
                    {   
                        Omega << s.process (in, c);

                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /** A compressor transfer function (CTF) with color
        
        Notes:
        - Algebraic bell-shaped function (derivative of a sigmoidal function arctan) used for color
        - See https://ocw.mit.edu/courses/mathematics/18-01sc-single-variable-calculus-fall-2010/1.-differentiation/part-falseStatement-implicit-differentiation-and-inverse-functions/session-15-implicit-differentiation-and-inverse-functions/MIT18_01SCF10_Ses15b.pdf
        - See https://blog.audio-tk.com/2015/09/08/audio-toolkit-additional-gain-functions/
    */
    namespace CTF
    {
        struct Coeffs 
        {
            SampleType thr;
            SampleType divR;
            SampleType height;
            SampleType divWidth; 
        }
    
        void update (Coeffs& c, float threshold, float ratio, float colorHeight, float colorWidth) 
        {
            c.thr = SampleType (threshold);
            c.divR = SampleType(1.0) / SampleType (ratio);
            c.height = SampleType (colorHeight);
            c.divWidth = SampleType(1.0) / SampleType (colorWidth);
        }
    
        SampleType process (SampleType x, Coeffs& c) 
        {
            const SampleType xdB = vgainTodB(x);

            const SampleType xdBmthr = xdB - c.thr;
            const SampleType temp = c.divWidth * (xdBmthr);
            const SampleType color = c.height / (SampleType(1.0) + temp * temp);
            SampleType ydB;
            

            if const (SIMD)
                return vif (c.thr + (xdBmthr) * c.divR + color, xdB + color, xdB > c.thr);
            else
            {
                if (xdB > c.thr)
                    ydB = c.thr + (xdBmthr) * c.divR + color;
                else
                    ydB = xdB + color;
            }

            return vdBtoGain(ydB) / x;
        }

        processor Processor(float initialThreshold = -20,
                            float initialRatio = 5,
                            float initialColorHeight = 5,
                            float initialColorWidth = 3)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event
            {
                float thresholdIn [[ name: "Threshold", min: -60.f, max: 0.f, init: initialThreshold, unit: "dB" ]];
                float ratioIn [[ name: "Ratio", min: 1.f, max: 100.f, init: initialRatio ]];
                float colorHeightIn [[ name: "Color Height", min: -12.f, max: 12.f, init: initialColorHeight, unit: "dB" ]];
                float colorWidthIn [[ name: "Color Width", min: -12.f, max: 12.f, init: initialColorWidth, unit: "dB" ]];
            }

            event thresholdIn (float v) { threshold = v; recalc = true; }
            event ratioIn (float v) { ratio = v; recalc = true; }
            event colorHeightIn (float v) { colorHeight = v; recalc = true; }
            event colorWidthIn (float v) { colorWidth = v; recalc = true; }

            float threshold = initialThreshold;
            float ratio = initialRatio;
            float colorHeight = initialColorHeight;
            float colorWidth = initialColorWidth;
            bool recalc = true;

            void run()
            {
                Coeffs c;
            
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (threshold, ratio, colorHeight, colorWidth);
                    }
    
                    loop (updateInterval)
                    {
                        out << process (in, c);
    
                        advance();
                    }
                }
            }
        }
    }


     //==============================================================================
    /** Nonlinear branching cutoff for making a nonlinear ballistics filter */
    // namespace BranchingCutoffFK
    // {
    //     struct Coeffs 
    //     {
    //         Lan::Coeffs attack;
    //         Lan::Coeffs release;
    //     }

    //     void update (Coeffs& c, MonoType attack, MonoType release, MonoType nonlinearity) 
    //     {
    //         Lan::updateStep(c.attack, attack, nonlinearity);
    //         Lan::updateStep(c.release, release, nonlinearity);
    //     }

    //     SampleType process (SampleType x, SampleType y, Coeffs& c) 
    //     {
    //         return x > y ? Lan::process(x, c.attack) : Lan::process(x, c.release);   
    //     }

    //     processor Processor(MonoType initialAttack,
    //                         MonoType initialRelease,
    //                         MonoType initialNonlinearity)
    //     {
    //         input stream SampleType x, y;
    //         output stream SampleType L;
    
    //         MonoType attack = initialAttack;
    //         MonoType release = initialRelease;
    //         MonoType nonlinearity = initialNonlinearity;
    //         bool recalc = true;
    
    //         void run()
    //         {
    //             Coeffs c;
    
    //             loop
    //             {
    //                 if (recalc)
    //                 {
    //                     recalc = false;
    
    //                     c.update(attack, release, nonlinearity);
    //                 }
    
    //                 loop (updateInterval)
    //                 {
    //                     L << process(x, y, c);
    
    //                     advance();
    //                 }
    //             }
    //         }
    //     }
    // }

    //==============================================================================
    namespace BallisticsFilter
    {
        graph Processor (float initialAttack,
                    float initialRelease)
        {
            input stream SampleType in;
            output stream SampleType out;
        
            let
            {
                onepole = Onepole::Processor;
                branchingCutoff = BranchingCutoff::Processor(initialAttack, initialRelease);
            }
        
            connection
            {
                in -> onepole.in;

                in -> branchingCutoff.x;
                onepole.out -> [1] -> branchingCutoff.y;

                branchingCutoff.Omega -> onepole.Omega;
                
                onepole.out -> out;
            }
        }
    }

/*==============================================================================
High-Level Effects
==============================================================================*/

    //==============================================================================
    /** High-level Processors made using the 'VA' and 'soul' namespaces */
    namespace HighLevel
    {   
        //==============================================================================
        /** VA::JA_L modulating VA::Onepole */
        namespace OnepoleL
        {
            graph Processor (int initialMode = 0, 
                        float initialFrequency = 200.f,
                        float initialNonlinearity = 0.f)
            {
                input stream SampleType in;
                output stream SampleType out;
        
                input
                {
                    onepole.modeIn;
                    L.frequencyIn;
                    L.nonlinearityIn;
                }
        
                let
                {
                    onepole = Onepole::Processor(initialMode, 0);
                    L = Lan::Processor(initialFrequency, initialNonlinearity);
                }
        
                connection
                {
                    in -> L.in, onepole.in;

                    L.Omega -> onepole.Omega;

                    onepole.out -> out;
                }
            }
        }

        //==============================================================================
        /** A modified classical compressor sidechain
        
            Notes:
            - Maps sample to sample.
            - Nonlinear, time-invariant, and stateful.
            - 3 sidechain blocks:
            * Detector: ideal rectifier
            * Envelope Filter: nonlinear ballistics filter
            * Compressor Transfer Function: hard-knee with color  
        */
        namespace Sidechain
        {
            graph Processor (float initialThreshold,
                        float initialRatio,
                        float initialColorHeight,
                        float initialColorWidth,
                        float initialAttack,
                        float initialRelease,
                        float initialNonlinearity)
            {
                input stream SampleType in;
                output stream SampleType out;
            
                let
                {
                    detector = Abs::Processor;
                    ctf = CTF::Processor(initialThreshold, initialRatio, initialColorHeight, initialColorWidth);
                    ballistics = BallisticsFilter::Processor(initialAttack, initialRelease);
                }
            
                connection
                {
                    in -> detector.in;
                    detector.out -> ballistics.in;
                    ballistics.out -> ctf.in;
                    ctf.out -> out;
                }
            }
        }
    }
}

//TODO event endpoints and annotations
//TODO BBD chorus/delay
//TODO SIMD vs scalar performance
//TODO different linear filter output combos