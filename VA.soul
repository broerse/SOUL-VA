/*
MIT License

Copyright (c) 2021 Zhe Deng

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/** Title: VA (https://github.com/thezhe/SOUL-VA)

    Virtual analog library -- a collection of nonlinear, time-varying filters. Interface based on
    soul::filters (https://github.com/soul-lang/SOUL/blob/master/source/soul_library/soul_library_filters.soul).

    Notes:
    - The overall structure of this library is as close to that of soul::filters except for:
        * Different initialization parameters (No CoeffType -- SampleType is used for minimzed nonsimd-simd casting; default updateInterval is 32)
        * The filters are optimized for 44.1kHz sampling rate and 24-bit bit depth with reccomendations for under/oversampling
*/
namespace VA (using SampleType = float32,  
              int updateInterval = 32)
{
    static_assert (SampleType.primitiveType.isFloat, "Primitive type of 'SampleType' must be float32 or float64");
    static_assert ((SampleType.isVector || SampleType.isFloat), "'SampleType' must be float64, float32, or a vector of float64/float32");

    //==============================================================================
    /** soul::tpt::onepole modified for cutoff modulation via an input stream

        See oversampling reccomendation in endpoint comments
    */
    namespace Onepole
    {   
        struct Coeffs
        {
            SampleType b;
        }

        struct State
        {
            SampleType z1;
        }

        void clear (Coeffs& c)
        {
            c.b = SampleType (1);
        }

        void reset (State& s)
        {
            s.z1 = SampleType();
        }

        SampleType processLPF (State& s, SampleType x, Coeffs& c)
        {
            let vn = (x - s.z1) * c.b;
            let lpf = vn + s.z1;
            s.z1 = vn + lpf;
            return lpf;
        }

        SampleType processHPF (State& s, SampleType x, Coeffs& c)
        {
            return x - processLPF (s, x, c);
        }

        SampleType processAPF (State& s, SampleType x, Coeffs& c)
        {
            let lpf = processLPF (s, x, c);
            let hpf = x - lpf;
            return lpf - hpf;
        }

        processor Processor (int initialMode = 0, int cutoffMode = 0)
        {
            input stream SampleType in;
            input stream  SampleType Omega; //angular cutoff; must be > 0; oversample x2; use for any cutoffs
            input stream SampleType g; //integrator input gain; do not oversample; use for low cutoffs
            output stream SampleType out;

            input event float modeIn [[ name: "Mode", min: 0, max: 2, init: initialMode, text: "Lowpass|Highpass|Allpass" ]];

            event modeIn (float v) { mode = int (v); }

            int mode = initialMode;

            let Tdiv2 = SampleType (processor.period * 0.5);

            void run()
            {   
                State s;
                Coeffs c;

                loop
                {
                    if const (cutoffMode == 0)
                    {
                        let temp = Omega * Tdiv2; 
                        c.b = temp / (SampleType (1.0) + temp);
                    }
                    else 
                    {
                        c.b = g / (SampleType (1.0) + g);
                    }   

                    if (mode == 0)        out << s.processLPF (in, c);
                    else if (mode == 1)  out << s.processHPF (in, c);
                    else if (mode == 2)   out << s.processAPF (in, c);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** soul::tpt::svf modified for cutoff/resonance modulation via input streams
    
        2x oversampling recommended
    */  
    namespace SVF
    {
        struct Coeffs
        {
            SampleType a0;
            SampleType a;
            SampleType p;
        }

        struct State
        {
            SampleType[2] z;
        }

        void reset (State& s)
        {
            s.z[0] = SampleType();
            s.z[1] = SampleType();
        }

        SampleType[3] process (State& s, SampleType x, Coeffs& c)
        {
            let hpf = c.a0 * (x - c.p * s.z[0] - s.z[1]);
            let bpf = c.a * hpf + s.z[0];
            let lpf = c.a * bpf + s.z[1];

            s.z[0] = c.a * hpf + bpf;
            s.z[1] = c.a * bpf + lpf;

            return SampleType[3] (lpf, hpf, bpf);
        }

        processor Processor
        {
            input stream SampleType in;
            input stream SampleType Omega; //angular cutoff; must be > 0
            input stream SampleType R; //resonance; must be > 0
            output stream SampleType lowpassOut, highpassOut, bandpassOut;

            let Tdiv2 = SampleType (processor.period * 0.5); 

            void run()
            {
                State s;
                Coeffs c;

                loop
                {
                    c.a = Omega * Tdiv2; //g
                    c.a0 = SampleType (1.0) / (SampleType (1.0) + SampleType (2.0) * R * c.a + c.a * c.a); //d
                    c.p = SampleType (2.0) * R + c.a; //g1

                    let y = s.process(in, c);

                    lowpassOut  << y[0];
                    highpassOut << y[1];
                    bandpassOut << y[2];
                    
                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** Anhysteretic magnetic flux density curve (Ban).
        
            y[n] = a * x / (1.0 + |a * x|)

        Based on the Froehlich-Kennelley model.
        https://www.dafx.de/paper-archive/2015/DAFx-15_submission_68.pdf
    */
    namespace Ban
    {
        SampleType process (SampleType x, SampleType a)
        {
            let temp = a * x;
            return temp / (SampleType(1.0) + abs(temp));
        }
        
        processor Processor(float initialDrive = 1.f)
        {
            input stream SampleType in;
            output stream SampleType out;

            input event float driveIn [[ name: "Drive", min: 0, max: 1000, init: initialDrive ]];
            
            event driveIn (float v) { a = SampleType(v); }

            SampleType a = initialDrive;

            void run()
            {
                loop
                {
                    out << process(in, a);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** Anhysteretic inductance (Lan).

        Based on the Froehlich-Kennelley model.
        https://www.dafx.de/paper-archive/2015/DAFx-15_submission_68.pdf
    */
    namespace Lan
    {
        struct Coeffs
        {
            SampleType c; //affects linear Omega
            SampleType N; //nonlinearity
        }

        void clear (Coeffs& c)
        {
            c.c = SampleType();
            c.N = SampleType();
        }

        void update (Coeffs& c, SampleType freqHz, SampleType nonlinearity)
        {
            c.c = sqrt(SampleType(twoPi) * freqHz);
            c.N = nonlinearity;
        }

        SampleType process(SampleType x, Coeffs& c)
        {
            let temp = c.N * abs(x) + c.c;
            return temp * temp;
        }
        
        processor Processor(SampleType initialFrequency = 0,
                            SampleType initialNonlinearity = 400)
        {
            input stream SampleType in;
            output stream SampleType Omega;
            
            input event
            {
                float frequencyIn [[ name: "Frequency", min: 20, max: 18000, init: initialFrequency, unit: "Hz" ]];
                float nonlinearityIn [[ name: "Nonlinearity", min: 0, max: 1000, init: initialNonlinearity ]];
            }

            event frequencyIn (float v) { frequency = v; recalc = true; }
            event nonlinearityIn (float v) { nonlinearity = v; recalc = true; }

            SampleType frequency = initialFrequency;
            SampleType nonlinearity = initialNonlinearity;
            bool recalc = true;

            void run()
            {
                Coeffs c;
                c.clear();

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update(frequency, nonlinearity);
                    }

                    loop (updateInterval)
                    {   
                        Omega << process(in, c);

                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /** The input gain before a timeless trapezoidal integrator.
    
            y[n] = 0.5 * |x[n] - x[n-1]|
    */
    namespace TimelessIntGain
    {
        struct State
        {
            SampleType x1;
        }

        void reset (State& s)
        {
            s.x1 = SampleType();
        }
        
        SampleType process(State&s, SampleType x)
        {
            let y = abs(x - s.x1) * SampleType(0.5);
            s.x1 = x;

            return y;
        }

        processor Processor
        {
            input stream SampleType in;
            output stream SampleType g;
        
            void run()
            {
                State s;

                loop
                {
                    g << s.process(in);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** Irreversible magnetic flux density (Birr) and inductance (Lirr). 
    
        Based on the Jiles-Atherton model.
    */
    namespace Irreversible
    {
        graph Processor (int mode = Mode::Birr, float initialHysteresis)
        {
            input stream SampleType in;
            output stream SampleType out;

            input
            {
                ban.driveIn hysteresisIn;
            }

            let
            {
                ban = Ban::Processor(initialHysteresis);
                timeless = TimelessIntGain::Processor;
                onepole = Onepole::Processor(mode, 1);
            }
    
            connection
            {
                in -> ban.in;
                ban.out -> onepole.in;

                in -> timeless.in;
                timeless.g -> onepole.g;

                onepole.out -> out;
            }
        }

        namespace Mode
        {
            let Birr = 0;
            let Lirr = 1;
        }

    }

    //==============================================================================
    /** Audio-optimized Jiles-Atherton model for inductance (L).

        L(x) = dB/dx = dBirr/dx + dBan/dx = Lirr(x) + Lan(x)
    */
    namespace JA_L
    {
        graph Processor(float initialFrequency = 200, 
                    float initialNonlinearity = 0.f,
                    float initialHysteresis = 0.f)
        {
            input stream SampleType in;
            output stream SampleType Omega;

            input
            {
                lirr.hysteresisIn;
                lan.frequencyIn;
                lan.nonlinearityIn;
            }

            let
            {
                lan = Lan::Processor(initialFrequency, initialNonlinearity);
                lirr = Irreversible::Processor(1, initialHysteresis);
                clamper = Clamper::Processor(0);
                fGain = soul::gain::FixedGain(SampleType, 2.5 * initialFrequency);
            }
    
            connection
            {
                
                in -> lan.in, lirr.in;
                lan.Omega -> clamper.in;
                lirr.out -> fGain -> clamper.in;
                clamper.out -> Omega;                
            }
        }
    }

    //==============================================================================
    /** A compressor transfer function (CTF) with color
        
        Notes:
        - Maps sample to sample.
        - Nonlinear, time-invariant, stateless.
        - Algebraic bell-shaped function (derivative of a sigmoidal function arctan) used for color
        - See https://ocw.mit.edu/courses/mathematics/18-01sc-single-variable-calculus-fall-2010/1.-differentiation/part-b-implicit-differentiation-and-inverse-functions/session-15-implicit-differentiation-and-inverse-functions/MIT18_01SCF10_Ses15b.pdf
        - See https://blog.audio-tk.com/2015/09/08/audio-toolkit-additional-gain-functions/
    */
    namespace CTF
    {
        struct Coeffs 
        {
            SampleType thr;
            SampleType divR;
            SampleType height;
            SampleType divWidth; 
        }

        void clear (Coeffs& c) 
        {
            c.thr = SampleType();
            c.divR = SampleType();
            c.height = SampleType();
            c.divWidth = SampleType();
        }
    
        void update (Coeffs& c, SampleType threshold, SampleType ratio, SampleType colorHeight, SampleType colorWidth) 
        {
            c.thr = threshold;
            c.divR = SampleType(1.0) / ratio;
            c.height = colorHeight;
            c.divWidth = SampleType(1.0) / colorWidth;
        }
    
        SampleType process (SampleType x, Coeffs& c) 
        {
            const SampleType xdB = soul::gainTodB(x);

            const SampleType xdBmthr = xdB - c.thr;
            const SampleType temp = c.divWidth * (xdBmthr);
            const SampleType color = c.height / (SampleType(1.0) + temp * temp);
            SampleType ydB;
            
            if (xdB > c.thr)
                ydB = c.thr + (xdBmthr) * c.divR + color;
            else
                ydB = xdB + color;

            return soul::dBtoGain(ydB) / x;
        }

        processor Processor(SampleType initialThreshold = -20,
                            SampleType initialRatio = 5,
                            SampleType initialColorHeight = 5,
                            SampleType initialColorWidth = 3)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event
            {
                float thresholdIn [[ name: "Threshold", min: -60, max: 0, init: initialThreshold, unit: "dB" ]];
                float ratioIn [[ name: "Ratio", min: 1, max: 100, init: initialRatio ]];
                float colorHeightIn [[ name: "Color Height", min: -12, max: 12, init: initialColorHeight, unit: "dB" ]];
                float colorWidthIn [[ name: "Color Width", min: -12, max: 12, init: initialColorWidth, unit: "dB" ]];
            }

            event thresholdIn (float v) { threshold = v; recalc = true; }
            event ratioIn (float v) { ratio = v; recalc = true; }
            event colorHeightIn (float v) { colorHeight = v; recalc = true; }
            event colorWidthIn (float v) { colorWidth = v; recalc = true; }

            SampleType threshold = initialThreshold;
            SampleType ratio = initialRatio;
            SampleType colorHeight = initialColorHeight;
            SampleType colorWidth = initialColorWidth;
            bool recalc = true;

            void run()
            {
                Coeffs c;
                c.clear();
    
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update(threshold, ratio, colorHeight, colorWidth);
                    }
    
                    loop (updateInterval)
                    {
                        out << process(in, c);
    
                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /** Nonlinear branching cutoff for making a nonlinear ballistics filter

        Notes:
        - Maps filter output and input to cutoff.
        - Nonlinear, time-invariant, stateless.
    */
    namespace BranchingCutoff
    {  
        processor Processor(SampleType initialAttack,
                            SampleType initialRelease)
        {
            input stream SampleType x, y;
            output stream SampleType Omega;

            input event
            {
                float attackIn [[ name: "Attack", min: 1,   max: 200, init: initialAttack, unit: "ms"]];
                float releaseIn [[ name: "Frequency", min: 1,   max: 200, init: initialAttack, unit: "ms"]];
            }
    
            bool recalc = true;
    
            void run()
            {
                Coeffs c;
                c.clear();
    
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update(attack, release);
                    }
    
                    loop (updateInterval)
                    {
                        Omega << process (x, y, c); 
    
                        advance();
                    }
                }
            }
        }

        SampleType process (SampleType x, SampleType y, Coeffs& c) 
        {
            return x > y ? c.aOmega : c.rOmega;   
        }

        struct Coeffs 
        {
            SampleType aOmega;
            SampleType rOmega;
        }

        void clear (Coeffs& c) 
        {
            c.aOmega = 1;
            c.rOmega = 1;
        }

        void update (Coeffs& c, SampleType attack, SampleType release) 
        {
            c.aOmega = SampleType(1.0) / attack;
            c.rOmega = SampleType(1.0) / release;
        }
    }

    //==============================================================================
    namespace BallisticsFilter
    {
        graph Processor(SampleType initialAttack,
                    SampleType initialRelease,
                    SampleType initialNonlinearity)
        {
            input stream SampleType in;
            output stream SampleType out;
        
            let
            {
                onepole = Onepole::Processor;
                branchingCutoff = BranchingCutoff::Processor(initialAttack, initialRelease, initialNonlinearity);
            }
        
            connection
            {
                in -> onepole.in;

                in -> branchingCutoff.x;
                onepole.out -> [1] -> branchingCutoff.y;

                branchingCutoff.Omega -> onepole.Omega;
                
                onepole.out -> out;
            }
        }
    }

    //==============================================================================
    /** Set a vector equal to the average of its elements. */
    namespace StereoLink (bool initialEnabled = true)
    {
        processor Processor()
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event SampleType enabledIn [[ name: "Enabled", min: 0, max: 1, init: initialEnabled, unit: "Off|On" ]];
            
            event enabledIn (SampleType v) { enabled = bool(v); }

            bool enabled = initialEnabled;

            void run()
            {
                loop
                {
                    out << (enabled ? SampleType(in.sum()/in.size()) : in);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** Clamp the min, max, or both by setting min and/or max to values >= 0 */
    namespace Clamper
    {       
        processor Processor(float min = -1, float max = -1)
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    if const (min < 0)
                        out << min (in, SampleType(max));
                    else if const (max < 0)
                        out << max (in, SampleType(min));
                    else
                        out << clamp(in, SampleType(min), SampleType(max));
            
                    advance();
                }
            }
        }
    }

    //==============================================================================
    namespace Abs
    {
        processor Processor()
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << abs(in);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    namespace Multiply
    {
        processor Processor()
        {
            input stream SampleType in1, in2;
            output stream SampleType out;
    
            void run()
            {
                loop
                {
                    out << in1 * in2;
    
                    advance();
                }
            }
        }
    }

    //==============================================================================
    namespace Reciprocal
    {
        processor Processor()
        {
            input stream SampleType in;
            output stream SampleType out;
    
            void run()
            {
                loop
                {
                    out << SampleType (1.0) / in;
    
                    advance();
                }
            }
        }
    }

    //==============================================================================
    namespace OmegaTog
    {
        processor Processor()
        {
            input stream SampleType Omega;
            output stream SampleType g;
    
            let Tdiv2 = SampleType (processor.period * 0.5);

            void run()
            {
                loop
                {
                    g << Omega * Tdiv2;
    
                    advance();
                }
            }
        }
    }
    
    //==============================================================================
    // /** Timeless TDF-II Trapezoidal Differentiator 
    
    //     Find ((d/dx)^n)y using numerical differentiation  
    // */
    // namespace TimelessDiff (int order)
    // {
    //     struct State 
    //     {
    //         SampleType[order] z;
    //     }

    //     void reset (State& s) {}

    //     SampleType process (State& s, SampleType y, SampleType x) 
    //     {
                
    //     }

    //     processor Processor()
    //     {
    //         input stream SampleType y, x;
    //         output stream SampleType out;
    
    //         void run()
    //         {
    //             State s;
    
    //             loop
    //             {
    //                 out << s.process(y, x);

    //                 advance();
    //             }
    //         }
    //     }
    // }

    //==============================================================================
    /** High-level Processors made using the 'VA' and 'soul' namespaces */
    namespace HighLevel
    {
        //==============================================================================
        /** Audio-optimized Jiles-Atherton model for magnetic flux density.

            B(x) = Birr(x) + Ban(x)
        */
        namespace JA_B
        {
            graph Processor(SampleType initialDrive = SampleType(1),
                        SampleType initialGainBirr = SampleType(0),
                        SampleType initialGainBan = SampleType(1))
            {
                input stream SampleType in;
                output stream SampleType out;

                let
                {
                    birrLirr = Irreversible::Processor(0, initialDrive);

                    ban = Ban::Processor(initialDrive);

                    fixedSum = soul::mixers::FixedSum(SampleType, initialGainBirr, initialGainBan);
                }

                connection
                {
                    in -> birrLirr.in;
                    birrLirr.out -> fixedSum.in1;

                    in -> ban.in;
                    ban.out -> fixedSum.in2;

                    fixedSum.out -> out;
                }
            }
        }
        
        //==============================================================================
        /** VA::JA_L modulating VA::Onepole */
        namespace JA_Onepole
        {
            graph Processor (int initialMode = 0, 
                        float initialFrequency = 200.f,
                        float initialNonlinearity = 0.f,
                        float initialHysteresis = 0.f)
            {
                input stream SampleType in;
                output stream SampleType out;
        
                input
                {
                    onepole.modeIn;
                    jaL.frequencyIn;
                    jaL.hysteresisIn;
                    jaL.nonlinearityIn;
                }
        
                let
                {
                    onepole = Onepole::Processor(initialMode, 0);
                    jaL = JA_L::Processor(initialFrequency, initialNonlinearity);
                }
        
                connection
                {
                    in -> jaL.in, onepole.in;

                    jaL.Omega -> onepole.Omega;

                    onepole.out -> out;
                }
            }
        }

        //==============================================================================
        /** A modified classical compressor sidechain
        
            Notes:
            - Maps sample to sample.
            - Nonlinear, time-invariant, and stateful.
            - 3 sidechain blocks:
            * Detector: ideal rectifier
            * Envelope Filter: nonlinear ballistics filter
            * Compressor Transfer Function: hard-knee with color  
        */
        namespace Sidechain
        {
            graph Processor(SampleType initialThreshold,
                        SampleType initialRatio,
                        SampleType initialColorHeight,
                        SampleType initialColorWidth,
                        SampleType initialAttack,
                        SampleType initialRelease,
                        SampleType initialNonlinearity)
            {
                input stream SampleType in;
                output stream SampleType out;
            
                let
                {
                    detector = Abs::Processor;
                    ctf = CTF::Processor(initialThreshold, initialRatio, initialColorHeight, initialColorWidth);
                    ballistics = BallisticsFilter::Processor(initialAttack, initialRelease);
                }
            
                connection
                {
                    in -> detector.in;
                    detector.out -> ballistics.in;
                    ballistics.out -> ctf.in;
                    ctf.out -> out;
                }
            }
        }
    }
}

//TODO oversampling and ADAA
//TODO parameter limits and annotations for HighLevel
//TODO cutoff accuracy, linear behaviour