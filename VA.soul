/** MIT License

    Copyright (c) 2021 Zhe Deng

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

/** SOUL-VA (https://github.com/thezhe/SOUL-VA)

    See the README for an overview of this library

    Use with SOUL 1.0.82 (https://github.com/soul-lang/SOUL/releases/tag/1.0.82)

    The following interface is nearly identical to soul::filters EXCEPT:
    - Each effect is a 'Processor' under 'VA::HighLevel'
    - 'SampleType' must be a vector, even if the effect is mono
    - 'CoeffType' is not defined ('SampleType' is used internally for coefficients and samples)
    - SIMD-style bit masking is supported (see Sample-Agnostic Utilities)
    - The minimum settings are 44.1kHz/24-bit; see Processor-specific comments for other requirements
*/

namespace VA (using SampleType = float64<1>, int updateInterval = 32)
{
/*==============================================================================
Constants
==============================================================================*/
    
    //==============================================================================
    static_assert (SampleType.primitiveType.isFloat, "Primitive type of 'SampleType' must be float32 or float64");
    static_assert (SampleType.isVector, "'SampleType' must be a vector");
    static_assert (updateInterval > 0, "'updateInterval' must be greater than 0");

    //==============================================================================
    let SIMD = bool (SampleType.size > 1);

    //==============================================================================
    let N100dB = float (0.00001);
    let ADAA_TOL = SampleType (0.0000001);
    let inf32 = float (inf);
    let div20 = SampleType (1.0) / SampleType (20.0);

/*==============================================================================
Vector-Optimized Functions
==============================================================================*/

    //==============================================================================
    /** 'if' statement
    
        Not necessarily faster with vectors; use conservatively!
    */
    SampleType vif<BoolType> (SampleType trueStatement, SampleType falseStatement, BoolType condition)
    {   
        if const (SIMD)
            return trueStatement * SampleType (condition) + falseStatement * SampleType (!condition);
        else
        {
            if (condition)
                return trueStatement;
            else
                return falseStatement;
        }
    }

    //==============================================================================
    /** clamp a value between low and high

        If 'low' = inf32 or 'high' = inf32, they will be optimized out at compile time
    */
    namespace vclamp (float low = -inf32, float high = inf32)
    {       
        let l = SampleType (low);
        let h = SampleType (high);

        SampleType process (SampleType x)
        {
            if const (SIMD)
            {
                if const (low > -inf32 && high < inf32)
                    return vif (vif (x, l, x > l), h, x < h); 
                else if const (low > -inf32)
                    return vif (x, l, x > l);
                else
                    return vif (x, h, x < h);
            }
            else
            {
                if const (low > -inf32 && high < inf32)
                    return clamp(x, l, h);
                else if const (low > -inf32)
                    return max (x, l);
                else
                    return min (x, h);           
            }
        }

        processor Processor ()
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << process (in);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** Convert gain to decibels and clamp results to greater than -100.0 dB */
    SampleType vgainTodB (SampleType x)
    {
        if const (SIMD)
        {
            let temp = vclamp (N100dB, inf)::process(x);

            return SampleType (20.0) * log10 (temp);
        }
        else
        {
            if (x < N100dB)
                return SampleType (-100.0);
            
            return SampleType (20.0) * log10 (x);
        }
    }

    //==============================================================================
    /** Convert decibels to gain and clamp inputs to greater than -100.0 dB */
    SampleType vdBtoGain (SampleType x)
    {
        if const (SIMD)
        {
            let temp = vclamp (-100, inf)::process(x);

            return pow (SampleType (10.0), temp * div20);
        }
        else
        {
            if (x < SampleType (-100.0))
                return N100dB;
            
            return pow (SampleType (10.0), x * div20);
        }
    }

    //==============================================================================
    /** Return 1 if x is positive, -1 if negative, and 0 otherwise */
    SampleType vsgn (SampleType x)
    {
        return SampleType(x > SampleType (0.0)) - SampleType(x < SampleType (0.0));
    }
    
    //==============================================================================
    /** An continuously differentiable algebraic sigmoid function. 

            f(x) = x / sqrt (x^2 + 1) 
    
        A cheap approximation of 'tanh'
    */
    SampleType vsigmoidCD (SampleType x)
    {
        return x / sqrt (x * x + SampleType (1.0));
    }
    
    //==============================================================================
    /** An continuously differentiable algebraic bell-shaped function. 

            f(x) = x / (x^2 + 1) ^ (3/2) 
    
        Derivative of 'vsigmoid'
    */
    SampleType vbellCD (SampleType x)
    {
        let temp = x * x + SampleType (1.0);

        return SampleType (1.0) / sqrt (temp * temp * temp);
    }

    //==============================================================================
    /** Reciprocal of 'vbellCD' 

            f(x) = 1 / vbellCD(x) 
    */
    SampleType vrecbellCD (SampleType x)
    {
        let temp = x * x + SampleType (1.0);

        return temp * temp * temp;
    }

    //==============================================================================
    /** A continuously differentiable algebraic rectifying function. 

            f(x) = x * vsigmoidCD(x)
    */
    SampleType vabsCD (SampleType x)
    {
        return x * vsigmoid (SampleType (5.0) * x);
    }

    //==============================================================================
    SampleType vabs (SampleType x)
    {
        if const (SIMD)
        {
            SampleType y;

            for (wrap<SampleType.size> i)
                y[i] = abs (x[i]);
            
            return y;
        }
        else 
            return abs (x);
    }

    /** An algebraic sigmoid function. 

            f(x) = 1 / (abs(x) + 1) 
    
        A cheap approximation of 'tanh'
    */
    SampleType vsigmoid (SampleType x)
    {
        return x / (vabs(x) + SampleType (1.0));
    }

    //==============================================================================
    /** An algebraic sigmoid function. 

            f(x) = 1 / (abs(x) + 1) 
    
        A cheap approximation of 'tanh'
    */
    SampleType vbell (SampleType x)
    {
        let temp = vabs(x) + SampleType (1.0);
        
        return SampleType (1.0) / (temp * temp);
    }

    //==============================================================================
    /** Reciprocal of 'vbell' 

            f(x) = 1 / vbell(x) 
    */
    SampleType vrecbell (SampleType x)
    {
        let temp = vabs(x) + SampleType (1.0);

        return temp * temp;
    }

/*==============================================================================
Subgraphs and processors
==============================================================================*/

    //==============================================================================
    /** Cast primitives inType to outType */
    namespace Cast (using inType, using outType)
    {      
        static_assert (inType.isVector && outType.isVector, "inType must be a vector");
        static_assert (inType.size == outType.size, "inType must be the same size as outType");
        
        outType process (inType x)
        {
            outType y;

            for (wrap<inType.size> i)
                y[i] = outType.primitiveType (x[i]);

            return y;
        }

        processor Processor()
        {
            input stream inType in;
            output stream outType out;
    
            void run()
            {   
                loop
                {
                    out << process (in);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** Set a each vector element equal to the average of its elements 
    
        Do not use if vector size is 1!
    */
    namespace StereoLink
    {   
        struct Coeffs
        {
            bool e; //enabled
        }
    
        void update (Coeffs& c, float enabled)
        {
            c.e = bool (enabled);
        }
    
        SampleType process (SampleType x, Coeffs& c)
        {
            if const (SIMD)
                return (c.e ? SampleType (x.sum()/x.size) : x);
            else 
                return x;
        }
    
        processor Processor (bool initialEnabled = true)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event float enabledIn [[ name: "Enabled", min: 0, max: 1, init: float (initialEnabled), unit: "Off|On" ]];
            
            event enabledIn (float v) { enabled = v; recalc = true; }

            float enabled = float (initialEnabled);
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;
    
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (enabled);
                    }
    
                    loop (updateInterval)
                    {
                        out << process (in, c);
    
                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /** 'Processor' wrapper of 'vabs' 
    
        See Sample-Agnostic Utility Functions
    */
    namespace Rectifier
    {
        processor Processor()
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << vabs (in);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    namespace Multiplier
    {
        processor Processor()
        {
            input stream SampleType in1, in2;
            output stream SampleType out;
    
            void run()
            {
                loop
                {
                    out << in1 * in2;
    
                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** SOUL-VA's version of soul::filters::tpt::onepole  

        Notes:
        - 2x oversampling recommended
        - Structure is more consistent with SVF and oversampling is used instead of prewarping
    */
    namespace Onepole
    {   
        struct Coeffs
        {
            SampleType G;
        }

        struct State
        {
            SampleType s;
        }

        SampleType[2] process (State& s, SampleType x, Coeffs& c)
        {
            let v = (x - s.s) * c.G;
            let lpf = v + s.s;
            let hpf = x - lpf;

            s.s = v + lpf;

            return SampleType[2] (lpf, hpf);
        }

        void update (Coeffs& c, float64 frequency, float64 Tpi)
        {
            let g = Tpi * frequency;
            c.G = SampleType (g / (1.0 + g));
        }

        processor Processor (float initialFrequency)
        {
            input stream SampleType in;
            output stream SampleType lowpassOut, highpassOut;

            input event float frequencyIn [[ name: "Frequency", min: 20, max: 20000, init: initialFrequency, text: "Hz" ]];

            event frequencyIn (float v) { frequency = v; recalc = true; }

            float frequency = float (initialFrequency);
            bool recalc = true;

            void run()
            {   
                State s;
                Coeffs c;

                let Tpi = processor.period * pi;

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (float64 (frequency), Tpi);
                    }

                    loop (updateInterval)
                    {
                        let y = s.process (in, c);

                        lowpassOut << y[0];
                        highpassOut << y[1];

                        advance();
                    }
                }
            }
        }
    }

    // //==============================================================================
    // /** Onepole modified for cutoff modulation via an input stream

    //     Notes:
    //     - 2x oversampling recommended
    // */
    // namespace OnepoleC
    // {   
    //     processor Processor (int cutoffMode = 0)
    //     {
    //         input stream SampleType in;
    //         input stream SampleType Omega; //angular cutoff; must be > 0; oversample x2; use for any cutoffs
    //         input stream SampleType g; //integrator input gain; do not oversample; use for low cutoffs
    //         output stream SampleType lowpassOut, highpassOut;

    //         void run()
    //         {   
    //             Onepole::State s;
    //             Onepole::Coeffs c;

    //             let Tdiv2 = SampleType (processor.period * 0.5);

    //             loop
    //             {
    //                 if const (cutoffMode == 0)
    //                 {
    //                     let temp = Omega * Tdiv2; 
    //                     c.G = temp / (SampleType (1.0) + temp);
    //                 }
    //                 else 
    //                     c.G = g / (SampleType (1.0) + g);

    //                 let y = Onepole::process (s, in, c);

    //                 lowpassOut << y[0];
    //                 highpassOut << y[1];

    //                 advance();
    //             }
    //         }
    //     }
    // }

    //==============================================================================
    /** Onepole modified for state variable saturation

        Notes:
        - 2x oversampling recommended
    */
    namespace OnepoleS
    {   
        struct Coeffs
        {
            SampleType b;
        }

        void update (Coeffs& c, float drive)
        {
            c.b = dBtoGain (drive);
        }

        SampleType[2] process (Onepole::State& s, SampleType x, Coeffs& c)
        {
            let v = (x - s.s);
            let lpf = v + s.s;
            let hpf = x - lpf;

            s.s = SampleType (0.25) * vsigmoidCD (c.b * (v + lpf));

            return SampleType[2] (lpf, hpf);
        }

        processor Processor (float initialDrive)
        {
            input stream SampleType in;
            output stream SampleType lowpassOut, highpassOut;

            input event float driveIn [[ name: "Drive", min: 0, max: 20, init: initialDrive, text: "dB" ]];

            event driveIn (float v) { drive = v; recalc = true; }

            float drive = dBtoGain (initialDrive);
            bool recalc = true;

            void run()
            {   
                Onepole::State s;
                Coeffs c;

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (drive);
                    }

                    loop (updateInterval)
                    {
                        let y = s.process (in, c);

                        lowpassOut << y[0];
                        highpassOut << y[1];

                        advance();
                    }
                }
            }
        }
    }
    
    //==============================================================================
    /** soul::tpt::svf modified for cutoff/resonance modulation via input streams
    
        2x oversampling recommended
    */  
    namespace SVF
    {
        struct Coeffs
        {
            SampleType a0;
            SampleType a;
            SampleType p;
        }

        struct State
        {
            SampleType[2] z;
        }

        SampleType[3] process (State& s, SampleType x, Coeffs& c)
        {
            let hpf = c.a0 * (x - c.p * s.z[0] - s.z[1]);
            let bpf = c.a * hpf + s.z[0];
            let lpf = c.a * bpf + s.z[1];

            s.z[0] = c.a * hpf + bpf;
            s.z[1] = c.a * bpf + lpf;

            return SampleType[3] (lpf, hpf, bpf);
        }

        processor Processor()
        {
            input stream SampleType in;
            input stream SampleType Omega; //angular cutoff; must be > 0
            input stream SampleType R; //resonance; must be > 0
            output stream SampleType lowpassOut, highpassOut, bandpassOut;

            void run()
            {
                State s;
                Coeffs c;

                let Tdiv2 = SampleType (processor.period * 0.5); 

                loop
                {
                    c.a = Omega * Tdiv2; //g
                    c.a0 = SampleType (1.0) / (SampleType (1.0) + SampleType (2.0) * R * c.a + c.a * c.a); //d
                    c.p = SampleType (2.0) * R + c.a; //g1

                    let y = s.process(in, c);

                    lowpassOut  << y[0];
                    highpassOut << y[1];
                    bandpassOut << y[2];
                    
                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** Anhysteretic inductance (Lan).

        Omega = (N * |in| + c) ^ 2

        Based on the Froehlich-Kennelley model.
        https://www.dafx.de/paper-archive/2015/DAFx-15_submission_68.pdf
    */
    namespace Lan
    {
        struct Coeffs
        {
            SampleType c; //depends on freqHz
            SampleType N; //nonlinearity
        }

        void update (Coeffs& c, float frequency, float nonlinearity)
        {
            c.c = sqrt (SampleType (twoPi) * SampleType (frequency));
            c.N = SampleType (nonlinearity);
        }

        SampleType process(SampleType x, Coeffs& c)
        {
            let temp = c.N * vabs (x) + c.c;

            return temp * temp;
        }
        
        processor Processor(float initialFrequency = 0,
                            float initialNonlinearity = 10)
        {
            input stream SampleType in;
            output stream SampleType Omega;
            
            input event
            {
                float frequencyIn [[ name: "Frequency", min: 20, max: 18000, init: initialFrequency, unit: "Hz" ]];
                float nonlinearityIn [[ name: "Nonlinearity", min: 0, max: 100, init: initialNonlinearity ]];
            }

            event frequencyIn (float v) { frequency = v; recalc = true; }
            event nonlinearityIn (float v) { nonlinearity = v; recalc = true; }

            float frequency = initialFrequency;
            float nonlinearity = initialNonlinearity;
            bool recalc = true;

            void run()
            {
                Coeffs c;

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (frequency, nonlinearity);
                    }

                    loop (updateInterval)
                    {   
                        Omega << process(in, c);

                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /** 'Lan' with second-order antiderivative antialiasing
    
        Warning: ONLY use with 'float64' samples.
        2x oversampling recommended.
    */
    namespace LanADAA2
    {   
        struct Coeffs
        {
            //f
            Lan::Coeffs lanCoeffs;
            //F1
            SampleType cSq; //c*c
            SampleType cN;
            SampleType NSqDiv3; 
            //F2
            SampleType NSqDiv12;
            SampleType cNDiv3;
            SampleType cSqDiv2;
        }
    
        struct State
        {
            SampleType x_2;
            SampleType x_1;
            SampleType F2_1;
            SampleType F1_1;
        }
    
        void update (Coeffs& c, float frequency, float nonlinearity)
        {
            c.lanCoeffs.c = sqrt (SampleType (twoPi) * SampleType (frequency));
            c.lanCoeffs.N = SampleType (nonlinearity);
            
            c.cSq = c.lanCoeffs.c * c.lanCoeffs.c;
            c.cN = c.lanCoeffs.c * c.lanCoeffs.N;
            c.NSqDiv3 = (c.lanCoeffs.N * c.lanCoeffs.N) / SampleType (3.0);
        
            c.cSqDiv2 = c.cSq / SampleType (2.0);
            c.cNDiv3 = c.cN / SampleType (3.0);
            c.NSqDiv12 = c.NSqDiv3 / SampleType (4.0);
        }
        
        SampleType F2 (SampleType x, Coeffs& c)
        {
            let xSq = x * x;
            return xSq * (c.cSqDiv2 + c.cNDiv3 * x * vsgn(x) + c.NSqDiv12 * xSq);
        }
    
        SampleType F1 (SampleType x, Coeffs& c)
        {
            let xSq = x * x;
            let xCb = xSq * x;
            return c.cSq * x + c.cN * xSq * vsgn(x) + c.NSqDiv3 * xCb;   
        }
    
        SampleType f (SampleType x, Coeffs& c)
        {
            return Lan::process (x, c.lanCoeffs);
        }
    
        SampleType process (State& s, SampleType x, Coeffs& c)
        {
            //Find F1_0
            SampleType F1_0;
            
            let x_0mx_1 = x - s.x_1;
            let F2_0 = F2 (x, c);

            if const (SIMD)
            {
                F1_0 = vif (F1 (SampleType (0.5) * (x + s.x_1), c), 
                    (F2_0 - s.F2_1) / x_0mx_1,
                    vabs (x_0mx_1) < ADAA_TOL);
            }
            else
            {
                if (vabs (x_0mx_1) < ADAA_TOL)
                    F1_0 = F1 (SampleType (0.5) * (x + s.x_1), c);
                else
                    F1_0 = (F2_0 - s.F2_1) / x_0mx_1;
            }

            //Find f_0
            SampleType f_0;
            let x_0mx_2 = x - s.x_2;

            if const (SIMD)
            {
                let xBar = SampleType (0.5) * (x + s.x_2);
                let delta = xBar - x;

                let trueStatement = vif(F1 (SampleType (0.5) * (xBar + x), c),
                    (SampleType (2.0) / delta) * (F1 (xBar, c) + (F2_0 - F2 (xBar, c)) / delta),
                    vabs (delta) < ADAA_TOL);

                f_0 = vif (trueStatement, 
                    (SampleType (2.0) / (x_0mx_2)) * (F1_0 - s.F1_1), 
                    vabs (x_0mx_2) < ADAA_TOL);
            }
            else
            {
                if (vabs (x_0mx_2) < ADAA_TOL)
                {
                    let xBar = SampleType (0.5) * (x + s.x_2);
                    let delta = xBar - x;
        
                    if (vabs (delta) < ADAA_TOL)
                        f_0 = F1 (SampleType (0.5) * (xBar + x), c);
                    else
                        f_0 = (SampleType (2.0) / delta) * (F1 (xBar, c) + (F2_0 - F2 (xBar, c)) / delta);
                }
                else
                    f_0 = (SampleType (2.0) / (x_0mx_2)) * (F1_0 - s.F1_1);
            }

            //update s
            s.x_2 = s.x_1;
            s.x_1 = x;
            s.F2_1 = F2_0;
            s.F1_1 = F1_0;
    
            return f_0;
        }
    
        processor Processor(float initialFrequency = 0, float initialNonlinearity = 10)
        {
            input stream SampleType in;
            output stream SampleType Omega;
            
            input event
            {
                float frequencyIn [[ name: "Frequency", min: 20, max: 18000, init: initialFrequency, unit: "Hz" ]];
                float nonlinearityIn [[ name: "Nonlinearity", min: 0, max: 100, init: initialNonlinearity ]];
            }

            event frequencyIn (float v) { frequency = v; recalc = true; }
            event nonlinearityIn (float v) { nonlinearity = v; recalc = true; }

            float frequency = initialFrequency;
            float nonlinearity = initialNonlinearity;
            bool recalc = true;

            void run()
            {
                State s;
                Coeffs c;

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (frequency, nonlinearity);
                    }

                    loop (updateInterval)
                    {   
                        Omega << s.process (in, c);

                        advance();
                    }
                }
            }
        }
    }



    //==============================================================================
    /** A compressor transfer function (CTF) with color
        
        Notes:
        - Algebraic bell-shaped function (derivative of a sigmoidal function arctan) used for color
        - See https://ocw.mit.edu/courses/mathematics/18-01sc-single-variable-calculus-fall-2010/1.-differentiation/part-falseStatement-implicit-differentiation-and-inverse-functions/session-15-implicit-differentiation-and-inverse-functions/MIT18_01SCF10_Ses15b.pdf
        - See https://blog.audio-tk.com/2015/09/08/audio-toolkit-additional-gain-functions/
    */
    namespace CTF
    {
        struct Coeffs 
        {
            SampleType thr;
            SampleType divR;
            SampleType height;
            SampleType divWidth; 
        }
    
        void update (Coeffs& c, float threshold, float ratio, float colorHeight, float colorWidth) 
        {
            c.thr = SampleType (threshold);
            c.divR = SampleType (1.0) / SampleType (ratio);
            c.height = SampleType (colorHeight);
            c.divWidth = SampleType (1.0) / SampleType (colorWidth);
        }
    
        SampleType process (SampleType x, Coeffs& c) 
        {
            const SampleType xdB = vgainTodB(x);

            const SampleType xdBmthr = xdB - c.thr;
            const SampleType temp = c.divWidth * (xdBmthr);
            const SampleType color = c.height / (SampleType(1.0) + temp * temp);
            SampleType ydB;
            

            if const (SIMD)
                return vif (c.thr + (xdBmthr) * c.divR + color, xdB + color, xdB > c.thr);
            else
            {
                if (xdB > c.thr)
                    ydB = c.thr + (xdBmthr) * c.divR + color;
                else
                    ydB = xdB + color;
            }

            return vdBtoGain(ydB) / x;
        }

        processor Processor(float initialThreshold = -20,
                            float initialRatio = 5,
                            float initialColorHeight = 5,
                            float initialColorWidth = 3)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event
            {
                float thresholdIn [[ name: "Threshold", min: -60.f, max: 0.f, init: initialThreshold, unit: "dB" ]];
                float ratioIn [[ name: "Ratio", min: 1.f, max: 100.f, init: initialRatio ]];
                float colorHeightIn [[ name: "Color Height", min: -12.f, max: 12.f, init: initialColorHeight, unit: "dB" ]];
                float colorWidthIn [[ name: "Color Width", min: -12.f, max: 12.f, init: initialColorWidth, unit: "dB" ]];
            }

            event thresholdIn (float v) { threshold = v; recalc = true; }
            event ratioIn (float v) { ratio = v; recalc = true; }
            event colorHeightIn (float v) { colorHeight = v; recalc = true; }
            event colorWidthIn (float v) { colorWidth = v; recalc = true; }

            float threshold = initialThreshold;
            float ratio = initialRatio;
            float colorHeight = initialColorHeight;
            float colorWidth = initialColorWidth;
            bool recalc = true;

            void run()
            {
                Coeffs c;
            
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (threshold, ratio, colorHeight, colorWidth);
                    }
    
                    loop (updateInterval)
                    {
                        out << process (in, c);
    
                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /** Nonlinear branching cutoff for making a nonlinear ballistics filter */
    // namespace BranchingCutoffFK
    // {
    //     struct Coeffs 
    //     {
    //         Lan::Coeffs attack;
    //         Lan::Coeffs release;
    //     }

    //     void update (Coeffs& c, MonoType attack, MonoType release, MonoType nonlinearity) 
    //     {
    //         Lan::updateStep(c.attack, attack, nonlinearity);
    //         Lan::updateStep(c.release, release, nonlinearity);
    //     }

    //     SampleType process (SampleType x, SampleType y, Coeffs& c) 
    //     {
    //         return x > y ? Lan::process(x, c.attack) : Lan::process(x, c.release);   
    //     }

    //     processor Processor(MonoType initialAttack,
    //                         MonoType initialRelease,
    //                         MonoType initialNonlinearity)
    //     {
    //         input stream SampleType x, y;
    //         output stream SampleType L;
    
    //         MonoType attack = initialAttack;
    //         MonoType release = initialRelease;
    //         MonoType nonlinearity = initialNonlinearity;
    //         bool recalc = true;
    
    //         void run()
    //         {
    //             Coeffs c;
    
    //             loop
    //             {
    //                 if (recalc)
    //                 {
    //                     recalc = false;
    
    //                     c.update(attack, release, nonlinearity);
    //                 }
    
    //                 loop (updateInterval)
    //                 {
    //                     L << process(x, y, c);
    
    //                     advance();
    //                 }
    //             }
    //         }
    //     }
    // }

    //==============================================================================
    /** Modulating low pass with two different cutoffs for rising and falling input */
    namespace BallisticsFilter
    {
        graph Processor (float initialAttack,
                    float initialRelease)
        {
            input stream SampleType in;
            output stream SampleType out;
        
            let
            {
                onepole = Onepole::Processor;
                branchingCutoff = BranchingCutoff::Processor(initialAttack, initialRelease);
            }
        
            connection
            {
                in -> onepole.in;

                in -> branchingCutoff.x;
                onepole.out -> [1] -> branchingCutoff.y;

                branchingCutoff.Omega -> onepole.Omega;
                
                onepole.out -> out;
            }
        }
    }

/*==============================================================================
High-Level Graphs
==============================================================================*/

    //==============================================================================
    /** High-level Processors made using the 'VA' and 'soul' namespaces */
    namespace HighLevel
    {   
        // //==============================================================================
        // /** VA::JA_L modulating VA::Onepole */
        // namespace OnepoleL
        // {
        //     graph Processor (int initialMode = 0, 
        //                 float initialFrequency = 200.f,
        //                 float initialNonlinearity = 0.f)
        //     {
        //         input stream SampleType in;
        //         output stream SampleType out;
        
        //         input
        //         {
        //             onepole.modeIn;
        //             L.frequencyIn;
        //             L.nonlinearityIn;
        //         }
        
        //         let
        //         {
        //             onepole = Onepole::Processor(initialMode, 0);
        //             L = Lan::Processor(initialFrequency, initialNonlinearity);
        //         }
        
        //         connection
        //         {
        //             in -> L.in, onepole.in;

        //             L.Omega -> onepole.Omega;

        //             onepole.out -> out;
        //         }
        //     }
        // }
        
        //==============================================================================
        /** A modified classical compressor sidechain
        
            Notes:
            - Maps sample to sample.
            - Nonlinear, time-invariant, and stateful.
            - 3 sidechain blocks:
            * Detector: ideal rectifier
            * Envelope Filter: nonlinear ballistics filter
            * Compressor Transfer Function: hard-knee with color  
        */
        namespace Sidechain
        {
            graph Processor (float initialThreshold,
                        float initialRatio,
                        float initialColorHeight,
                        float initialColorWidth,
                        float initialAttack,
                        float initialRelease,
                        float initialNonlinearity)
            {
                input stream SampleType in;
                output stream SampleType out;
            
                let
                {
                    detector = Rectifier::Processor;
                    ballistics = BallisticsFilter::Processor(initialAttack, initialRelease);
                    ctf = CTF::Processor(initialThreshold, initialRatio, initialColorHeight, initialColorWidth);
                }
            
                connection
                {
                    in -> detector.in;
                    detector.out -> ballistics.in;
                    ballistics.out -> ctf.in;
                    ctf.out -> out;
                }
            }
        }
    }
}

//TODO OnepoleS constant c.G value and use soul::dBtoGain for primitives 
//TODO combine Onepoles into one nonlinear version
//TODO library refactor
//TODO 'soul render' float64 test using ADAA2
//TODO float64 coeff update
//TODO event endpoints and annotations
//TODO BBD chorus/delay
//TODO performance test
//TODO different linear filter output combos
//TODO soultest which intrinsics support SIMD