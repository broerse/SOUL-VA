/*
MIT License

Copyright (c) 2021 Zhe Deng

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/** Title: VA (https://github.com/thezhe/SOUL-VA)

    Virtual analog library -- a collection of nonlinear, time-varying filters. Interface based on
    soul::filters (https://github.com/soul-lang/SOUL/blob/master/source/soul_library/soul_library_filters.soul).

    Notes:
    - The overall structure of this library is as close to that of soul::filters except for:
        * Different initialization parameters (No CoeffType -- SampleType is used for minimzed nonsimd-simd casting, default updateInterval is 32)
        * The filters are optimized for 44.1kHz sampling rate and 24-bit bit depth with nonlinear filters internally oversampled to 88.2kHz
*/
namespace VA (using SampleType = float32,  
              int updateInterval = 32)
{
    static_assert (SampleType.primitiveType.isFloat, "Primitive type of 'SampleType' must be float32 or float64");
    static_assert ((SampleType.isVector || SampleType.isFloat), "'SampleType' must be float64, float32, or a vector of float64/float32");

    using CoeffType = SampleType.primitiveType;

    //==============================================================================
    /** soul::tpt::onepole modified for cutoff modulation via an input stream

        Should be used with 2x oversampling
    */  
    namespace Onepole
    {
        namespace Mode
        {
            let lowpass  = 0;
            let highpass = 1;
            let allpass  = 2;
        }        

        struct Coeffs
        {
            SampleType b;
        }

        struct State
        {
            SampleType z1;
        }

        void clear (Coeffs& c)
        {
            c.b = SampleType (1);
        }

        void reset (State& s)
        {
            s.z1 = SampleType();
        }

        SampleType processLPF (State& s, SampleType x, Coeffs& c)
        {
            let vn = (x - s.z1) * c.b;
            let lpf = vn + s.z1;
            s.z1 = vn + lpf;
            return lpf;
        }

        SampleType processHPF (State& s, SampleType x, Coeffs& c)
        {
            return x - processLPF (s, x, c);
        }

        SampleType processAPF (State& s, SampleType x, Coeffs& c)
        {
            let lpf = processLPF (s, x, c);
            let hpf = x - lpf;
            return lpf - hpf;
        }

        processor Processor (int initialMode = 0)
        {
            input stream SampleType in;
            input stream  SampleType Omega; //angular cutoff; must be > 0
            output stream SampleType out;

            input event float modeIn [[ name: "Mode", min: 0, max: 2, init: 0, text: "Lowpass|Highpass|Allpass" ]];
            
            static_assert((initialMode >= 0 || initialMode <= 2), "Onepole: Mode must be 0 (LPF1), 1 (HPF1), or 2 (APF1)");

            event modeIn (float v) { mode = int (v); }

            int mode = initialMode;

            let Tdiv2 = SampleType (processor.period * 0.5);

            void run()
            {   
                State s;
                Coeffs c;

                loop
                {
                    let g = Omega * Tdiv2; 
                    c.b = g / (SampleType (1.0) + g);
                        
                    if (mode == Mode::lowpass)        out << s.processLPF (in, c);
                    else if (mode == Mode::highpass)  out << s.processHPF (in, c);
                    else if (mode == Mode::allpass)   out << s.processAPF (in, c);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** soul::tpt::svf modified for cutoff/resonance modulation via input streams and minimal nonsimd-simd casting */  
    namespace SVF
    {
        namespace Mode
        {
            let lowpass  = 0;
            let highpass = 1;
            let bandpass = 2;
        }

        struct Coeffs
        {
            SampleType a0;
            SampleType a;
            SampleType p;
        }

        struct State
        {
            SampleType[2] z;
        }

        void reset (State& s)
        {
            s.z[0] = SampleType();
            s.z[1] = SampleType();
        }

        SampleType[3] process (State& s, SampleType x, Coeffs& c)
        {
            let hpf = c.a0 * (x - c.p * s.z[0] - s.z[1]);
            let bpf = c.a * hpf + s.z[0];
            let lpf = c.a * bpf + s.z[1];

            s.z[0] = c.a * hpf + bpf;
            s.z[1] = c.a * bpf + lpf;

            return SampleType[3] (lpf, hpf, bpf);
        }
        processor Processor
        {
            input stream SampleType in;
            input stream SampleType Omega; //angular cutoff; must be > 0
            input stream SampleType R; //resonance; must be > 0
            output stream SampleType lowpassOut, highpassOut, bandpassOut;

            let Tdiv2 = SampleType (processor.period * 0.5); 

            void run()
            {
                State s;
                Coeffs c;

                loop
                {
                    c.a = Omega * Tdiv2; //g
                    c.a0 = SampleType(1.0) / (SampleType(1.0) + SampleType(2.0) * R * c.a + c.a * c.a); //d
                    c.p = SampleType(2.0) * R + c.a; //g1

                    let y = s.process(in, c);

                    lowpassOut  << y[0];
                    highpassOut << y[1];
                    bandpassOut << y[2];
                    
                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** Anhysteretic magnetic flux density curve (Ban).
        
            y[n] = a * x / (1.0 + |a * x|)

        Based on the Froehlich-Kennelley model.
        https://www.dafx.de/paper-archive/2015/DAFx-15_submission_68.pdf
    */
    namespace Ban
    {
        SampleType process(SampleType x)
        {
            return x / (SampleType(1.0) + abs(x));
        }

        processor Processor(float initialDrive = 1.f)
        {
            input stream SampleType in;
            output stream SampleType out;

            input event float driveIn [[ name: "Drive", min: 0, max: 10, init: 0 ]];
            
            event driveIn (float v) { a = SampleType(v); }

            SampleType a = initialDrive;

            void run()
            {
                loop
                {
                    out << process(a * in);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** Anhysteretic inductance (Lan).

        Based on the Froehlich-Kennelley model.
        https://www.dafx.de/paper-archive/2015/DAFx-15_submission_68.pdf
    */
    namespace Lan
    {
        struct Coeffs
        {
            SampleType c; //linear cutoff
            SampleType N; //nonlinearity
        }

        void clear (Coeffs& c)
        {
            c.c = SampleType();
            c.N = SampleType();
        }

        void update (Coeffs& c, SampleType freqHz, SampleType nonlinearity)
        {
            c.c = sqrt(SampleType(1.0) / (SampleType(twoPi) * freqHz));
            c.N = nonlinearity;
        }

        SampleType process(SampleType x, Coeffs& c)
        {
            const SampleType sqrtDenom = c.N * abs(x) + c.c;
            return SampleType(1.0) / (sqrtDenom * sqrtDenom);
        }
        
        const SampleType minNonlinearity = 0;
        const SampleType maxNonlinearity = 5000;

        processor Processor(SampleType initialFrequency = filt::defaultFreqHz,
                            SampleType initialNonlinearity = 400)
        {
            input stream SampleType in;
            output stream SampleType L;
            
            input event
            {
                SampleType frequencyIn [[ name: "Frequency", min: filt::minFreqHz, max: filt::maxFreqHz, init: filt::defaultFreqHz, unit: "Hz" ]];
                SampleType nonlinearityIn [[ name: "Nonlinearity", min: minNonlinearity, max: maxNonlinearity, init: initialNonlinearity ]];
            }

            static_assert((initialFrequency >= filt::minFreqHz && initialFrequency <= filt::maxFreqHz), "Lan: Cutoff Frequency must be in interval [0, samplingRate/2)");

            event frequencyIn (SampleType v) { frequency = v; recalc = true; }
            event nonlinearityIn (SampleType v) { nonlinearity = v; recalc = true; }

            SampleType frequency = initialFrequency;
            SampleType nonlinearity = initialNonlinearity;
            bool recalc = true;

            void run()
            {
                Coeffs c;
                c.clear();

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update(frequency, nonlinearity);
                    }

                    loop (updateInterval)
                    {   
                        L << process(in, c);

                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /** The trapezoidal integrator input gain used in timeless integration.
    
            y[n] = 0.5 * |x[n] - x[n-1]|
    */
    namespace TimelessGain
    {
        struct State
        {
            SampleType x1;
        }

        void reset (State& s)
        {
            s.x1 = SampleType();
        }
        
        SampleType process(State&s, SampleType x)
        {
            const SampleType y = abs(x - s.x1) * SampleType(0.5);
            s.x1 = x;

            return y;
        }

        processor Processor
        {
            input stream SampleType in;
            output stream SampleType out;
        
            void run()
            {
                State s;

                loop
                {
                    out << s.process(in);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** Irreversible magnetic flux density (Birr) and inductance (Lirr). */
    namespace Irreversible
    {
        namespace Mode
        {
            let Birr = 0;
            let Lirr = 1;
        }

        graph Graph (int mode = Mode::Birr, SampleType initialDrive)
        {
            input stream SampleType in;
            output stream SampleType out;
     
            static_assert((mode == Mode::Birr || mode == Mode::Lirr), "Irreversible: mode must be Mode::Birr (0) or Mode::Lirr (1)");

            let
            {
                ban = Ban::Processor(initialDrive);
                birrLirrCutoff = BirrLirrCutoff::Processor;
                onepole = Onepole::Processor(mode);
            }
    
            connection
            {
                in -> ban.in;
                ban.out -> onepole.in;

                in -> birrLirrCutoff.in;
                birrLirrCutoff.omegadiv2 -> onepole.omegadiv2;

                onepole.out -> out;
            }
        }
    }



    //==============================================================================
    /** A compressor transfer function (CTF) with color
        
        Notes:
        - Maps sample to sample.
        - Nonlinear, time-invariant, stateless.
        - Algebraic bell-shaped function (derivative of a sigmoidal function arctan) used for color
        - See https://ocw.mit.edu/courses/mathematics/18-01sc-single-variable-calculus-fall-2010/1.-differentiation/part-b-implicit-differentiation-and-inverse-functions/session-15-implicit-differentiation-and-inverse-functions/MIT18_01SCF10_Ses15b.pdf
        - See https://blog.audio-tk.com/2015/09/08/audio-toolkit-additional-gain-functions/
    */
    namespace CTF
    {
        struct Coeffs 
        {
            SampleType thr;
            SampleType divR;
            SampleType height;
            SampleType divWidth; 
        }

        void clear (Coeffs& c) 
        {
            c.thr = SampleType();
            c.divR = SampleType();
            c.height = SampleType();
            c.divWidth = SampleType();
        }
    
        void update (Coeffs& c, SampleType threshold, SampleType ratio, SampleType colorHeight, SampleType colorWidth) 
        {
            c.thr = threshold;
            c.divR = SampleType(1.0) / ratio;
            c.height = colorHeight;
            c.divWidth = SampleType(1.0) / colorWidth;
        }
    
        SampleType process (SampleType x, Coeffs& c) 
        {
            const SampleType xdB = soul::gainTodB(x);

            const SampleType xdBmthr = xdB - c.thr;
            const SampleType temp = c.divWidth * (xdBmthr);
            const SampleType color = c.height / (SampleType(1.0) + temp * temp);
            SampleType ydB;
            
            if (xdB > c.thr)
                ydB = c.thr + (xdBmthr) * c.divR + color;
            else
                ydB = xdB + color;

            return soul::dBtoGain(ydB) / x;
        }
    
        /** Processor parameter min/max */
        const SampleType minThreshold = SampleType(-60.0);
        const SampleType maxThreshold = SampleType(0.0);
        const SampleType minRatio = SampleType(1.0);
        const SampleType maxRatio = SampleType(25.0);
        const SampleType minColorHeight = SampleType(-5.0);
        const SampleType maxColorHeight = SampleType(5.0);
        const SampleType minColorWidth = SampleType(0.2);
        const SampleType maxColorWidth = SampleType(3.0);

        
        processor Processor(SampleType initialThreshold = -20,
                            SampleType initialRatio = 5,
                            SampleType initialColorHeight = 5,
                            SampleType initialColorWidth = 3)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event
            {
                SampleType thresholdIn [[ name: "Threshold", min: minThreshold, max: maxThreshold, init: initialThreshold, unit: "dB" ]];
                SampleType ratioIn [[ name: "Ratio", min: minRatio, max: maxRatio, init: initialRatio ]];
                SampleType colorHeightIn [[ name: "Color Height", min: minColorHeight, max: maxColorHeight, init: initialColorHeight, unit: "dB" ]];
                SampleType colorWidthIn [[ name: "Color Width", min: minColorWidth, max: maxColorWidth, init: initialColorWidth, unit: "dB" ]];
            }

            static_assert((initialThreshold >= minThreshold && initialThreshold <= maxThreshold), "CTF: Threshold must be in the interval [-60, 0] dB");
            static_assert((initialRatio >= minRatio && initialRatio <= maxRatio), "CTF: Ratio must be in the interval [1, 25]");
            static_assert((initialColorHeight >= minColorHeight && initialColorHeight <= maxColorHeight), "CTF: Color Height must be in the interval [-5, 5] dB");
            static_assert((initialColorWidth >= minColorWidth && initialColorWidth <= maxColorWidth), "CTF: Color Width must be in the interval [0.2, 3] dB");

            event thresholdIn (SampleType v) { threshold = v; recalc = true; }
            event ratioIn (SampleType v) { ratio = v; recalc = true; }
            event colorHeightIn (SampleType v) { colorHeight = v; recalc = true; }
            event colorWidthIn (SampleType v) { colorWidth = v; recalc = true; }

            SampleType threshold = initialThreshold;
            SampleType ratio = initialRatio;
            SampleType colorHeight = initialColorHeight;
            SampleType colorWidth = initialColorWidth;
            bool recalc = true;

            void run()
            {
                Coeffs c;
                c.clear();
    
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update(threshold, ratio, colorHeight, colorWidth);
                    }
    
                    loop (updateInterval)
                    {
                        out << process(in, c);
    
                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /** Nonlinear branching cutoff for making a nonlinear ballistics filter

        Notes:
        - Maps filter output and input to cutoff.
        - Nonlinear, time-invariant, stateless.
    */
    namespace BranchingCutoff
    {
        /** Holds a set of filter coefficients. */
        struct Coeffs 
        {
            Lan::Coeffs attack;
            Lan::Coeffs release;
        }

        /** Clears a set of coefficients. */
        void clear (Coeffs& c) 
        {
            Lan::clear(c.attack);
            Lan::clear(c.release);
        }
    
        /** Updates a set of coefficients for the given settings. */
        void update (Coeffs& c, SampleType attack, SampleType release, SampleType nonlinearity) 
        {
            Lan::updateStep(c.attack, attack, nonlinearity);
            Lan::updateStep(c.release, release, nonlinearity);
        }
    
        
        SampleType process (SampleType x, SampleType y, Coeffs& c) 
        {
            return x > y ? Lan::process(x, c.attack) : Lan::process(x, c.release);   
        }
    
        
        processor Processor(SampleType initialAttack,
                            SampleType initialRelease,
                            SampleType initialNonlinearity)
        {
            input stream SampleType x, y;
            output stream SampleType L;
    
            SampleType attack = initialAttack;
            SampleType release = initialRelease;
            SampleType nonlinearity = initialNonlinearity;
            bool recalc = true;
    
            void run()
            {
                Coeffs c;
                c.clear();
    
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update(attack, release, nonlinearity);
                    }
    
                    loop (updateInterval)
                    {
                        L << process(x, y, c);
    
                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /** Nonlinear envelope filter

        Notes:
        - Maps sample to sample.
        - Nonlinear, time-invariant, stateful.
    */
    namespace EnvelopeFilter
    {
        graph Graph(SampleType initialAttack,
                    SampleType initialRelease,
                    SampleType initialNonlinearity)
        {
            input stream SampleType in;
            output stream SampleType out;
        
            let
            {
                onepole = Onepole::Processor;
                branchingCutoff = BranchingCutoff::Processor(initialAttack, initialRelease, initialNonlinearity);
                p_OmegaToomegadiv2 = OmegaToomegadiv2::Processor;
            }
        
            connection
            {
                in -> onepole.in;

                in -> branchingCutoff.x;
                onepole.out -> [1] -> branchingCutoff.y;
                branchingCutoff.L -> p_OmegaToomegadiv2.Omega;
                p_OmegaToomegadiv2.omegadiv2 -> onepole.omegadiv2;

                onepole.out -> out;
            }
        }
    }

    //==============================================================================
    /** Set a vector equal to the average of its elements. */
    namespace StereoLink (bool initialEnabled = true)
    {
        processor Processor()
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event SampleType enabledIn [[ name: "Enabled", min: 0, max: 1, init: initialEnabled, unit: "Off|On" ]];
            
            event enabledIn (SampleType v) { enabled = bool(v); }

            bool enabled = initialEnabled;

            void run()
            {
                loop
                {
                    out << (enabled ? SampleType(in.sum())/SampleType(in.size()) : in);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    namespace ZeroClamp
    {       
        processor Processor()
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << max(in, CoeffType(0.0));
            
                    advance();
                }
            }
        }
    }

    //==============================================================================
    namespace Abs
    {
        processor Processor()
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << abs(in);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    namespace Add
    {
        processor Processor()
        {
            input stream SampleType in1, in2;
            output stream SampleType out;
    
            void run()
            {
                loop
                {
                    out << in1 + in2;
    
                    advance();
                }
            }
        }
    }

    //==============================================================================
    namespace Multiply
    {
        processor Processor()
        {
            input stream SampleType in1, in2;
            output stream SampleType out;
    
            void run()
            {
                loop
                {
                    out << in1 * in2;
    
                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** Top-level effect graphs. These effects are made using other namespaces in 'VA' and the 'soul' namespaces. */
    namespace TopLevel
    {
        //==============================================================================
        /** Jiles-Atherton model. Calculate a signal transforming into a hysteretic magnetic flux density.

            B(x) = Birr(x) + Ban(x)

            Notes:
            - Maps sample to sample.
            - Nonlinear, time-varying, and stateful.
            - Output simulates the core magnetization of a nonlinear, hysteretic inductor.
            - 1/Output simulates the charge of a nonlinear, hysteretic capacitor.
        */
        namespace JA_B
        {
            
            graph Graph(SampleType initialDrive = SampleType(1),
                        SampleType initialGainBirr = SampleType(0),
                        SampleType initialGainBan = SampleType(1))
            {
                input stream SampleType in;
                output stream SampleType out;

                let
                {
                    birrLirr = Irreversible::Graph(0, initialDrive);

                    ban = Ban::Processor(initialDrive);

                    fixedSum = soul::mixers::FixedSum(SampleType, initialGainBirr, initialGainBan);
                }

                connection
                {
                    in -> birrLirr.in;
                    birrLirr.out -> fixedSum.in1;

                    in -> ban.in;
                    ban.out -> fixedSum.in2;

                    fixedSum.out -> out;
                }
            }
        }

        //==============================================================================
        /** Derivative of the Jiles-Atherton model. Calculate hysteretic nonlinear passive component value.

            L(x) = dB/dx = dBirr/dx + dBan/dx = Lirr(x) + Lan(x)

            Notes:
            - Maps sample to cutoff.
            - Nonlinear, time-varying, and stateful.
            - Output simulates the inductance of a nonlinear, hysteretic inductor.
            - 1/Output simulates the capacitance of a nonlinear, hysteretic capacitor.
        */
        namespace JA_L
        {
            
            graph Graph(SampleType initialFrequency = filt::defaultFreqHz, 
                        SampleType initialNonlinearity = SampleType(0),
                        SampleType initialGainMirr = SampleType(0))
            {
                input stream SampleType in;
                output stream SampleType omegadiv2;

                let
                {
                    lirr = Irreversible::Graph(1, initialNonlinearity*SampleType(500));
                    lan = Lan::Processor(initialFrequency, initialNonlinearity/SampleType(50));
                    fixedSum = soul::mixers::FixedSum(SampleType, initialFrequency*initialGainMirr, SampleType(1.0));
                    p_OmegaToomegadiv2 = OmegaToomegadiv2::Processor(3);
                }
        
                connection
                {
                    in -> lirr.in;
                    lirr.out -> fixedSum.in1;

                    in -> lan.in;
                    lan.L -> fixedSum.in2;

                    fixedSum.out -> p_OmegaToomegadiv2.Omega;

                    p_OmegaToomegadiv2.omegadiv2 -> omegadiv2;
                }
            }
        }
        
        //==============================================================================
        /** Hysteretic nonlinear passive component cutoff modulation applied to Onepole

            Notes:
            - Maps sample to sample.
            - Nonlinear, time-invariant, and stateful.
        */
        namespace JA_Onepole
        {
            graph Graph(SampleType initialFrequency = filt::defaultFreqHz, 
                        SampleType initialNonlinearity = SampleType(0),
                        SampleType initialGainMirr = SampleType(0),
                        int initialMode = 0)
            {
                input stream SampleType in;
                output stream SampleType out;
        
                input
                {
                    //event endpoints
                }
        
                let
                {
                    jaL = JA_L::Graph(initialFrequency, initialNonlinearity, initialGainMirr);
                    onepole = Onepole::Processor(initialMode);
                }
        
                connection
                {
                    in -> jaL.in;

                    in -> onepole.in;
                    jaL.omegadiv2 -> onepole.omegadiv2;

                    onepole.out -> out;
                }
            }
        }

        //==============================================================================
        /** A modified classical compressor sidechain
        
            Notes:
            - Maps sample to sample.
            - Nonlinear, time-invariant, and stateful.
            - 3 sidechain blocks:
            * Detector: ideal rectifier
            * Envelope Filter: nonlinear ballistics filter
            * Compressor Transfer Function: hard-knee with color  
        */
        namespace Sidechain
        {
            graph Graph(SampleType initialThreshold,
                        SampleType initialRatio,
                        SampleType initialColorHeight,
                        SampleType initialColorWidth,
                        SampleType initialAttack,
                        SampleType initialRelease,
                        SampleType initialNonlinearity)
            {
                input stream SampleType in;
                output stream SampleType out;
            
                let
                {
                    detector = Abs::Processor;
                    ctf = CTF::Processor(initialThreshold, initialRatio, initialColorHeight, initialColorWidth);
                    envelopeFilter = EnvelopeFilter::Graph(initialAttack, initialRelease, initialNonlinearity);
                }
            
                connection
                {
                    in -> detector.in;
                    detector.out -> envelopeFilter.in;
                    envelopeFilter.out -> ctf.in;
                    ctf.out -> out;
                }
            }
        }
    }
}

//TODO finish initialization parameters
//TODO static asserts and remove min/max constants
//TODO add input events
//TODO over/undersampling
//TODO add increasing cutoff nonlinearity