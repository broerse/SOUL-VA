/** GNU GPLv3 License

    Copyright (C) 2021 ZheDeng
    TheZheDeng@gmail.com

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

/** SOUL-VA (https://github.com/thezhe/SOUL-VA)

    The following interface is nearly identical to soul::filters EXCEPT:
    - Each effect is a 'Processor' under 'VA::HighLevel'
    - No user defined types:
        *'SampleType' is float64<2>
        *The internal 'CoeffType' is float64<2>
        *Coefficient 'updateInterval' is every 128 samples at 44.1kHz 
        or scaled as needed (i.e. every 256 samples at 88.2kHz)
    - Expanded set of vector-friendly functions (see 'Vector Operations')
    - All effects are optimized for 44.1kHz/24-bit/stereo. 
    Higher sample rates and bit depths degrade performance 
    without guaranteeing better quality!
*/

/** Task List

    Current Tasks:
    - double check LanADAA

    Future Tasks:
    - initialization lists only for Processors and not namespaces
    - state reset event input
    - refactor snippets, fix adaa and add init to va::processor
    - SVF/OnepoleS/Compressor Components refactor and use
    - OnepoleS constant c.G value and use soul::dBtoGain for primitives 
    - BBD chorus/delay
    - state saturation
    - fix all vlt and vgt to viflt and vifgt
*/

namespace VA 
{
/*==============================================================================
High-Level Processors
==============================================================================*/

    /** High-level Processors made using the 'VA' and 'soul' namespaces */
    namespace HighLevel
    {   
        /** VA::LanADAA modulating VA::OnepoleC in all pass mode */
        namespace OnepoleC_Lan
        {
            graph Processor (float initialNonlinearity = 0.f, float initialStereoLink = 0.f)
            {
                input stream SampleType in;
                output stream SampleType out;
        
                input
                {
                    internal.nonlinearityIn;
                    stereoLink.stereoLinkIn;
                    internal.resetIn;
                }
        
                let
                {
                    dcBlocker = filt::dc_blocker::Processor (5.f);
                    stereoLink = StereoLink::Processor (initialStereoLink);

                    internal = Internal::OnepoleC_Lan::Processor (initialNonlinearity) * 2;

                    onepoleMixer = OnepoleMixer::Processor (2);
                }
        
                connection
                {
                    in -> dcBlocker -> stereoLink.in, internal.in;

                    stereoLink.out -> internal.Lin;

                    internal.highpassOut -> onepoleMixer.highpassIn;
                    internal.lowpassOut -> onepoleMixer.lowpassIn;
                    
                    onepoleMixer.out -> out;
                }
            }
        }
        
        /** A modified classical compressor sidechain
        
            Notes:
            - Maps sample to sample.
            - Nonlinear, time-invariant, and stateful.
            - 3 sidechain blocks:
            * Detector: ideal rectifier
            * Envelope Filter: nonlinear ballistics filter
            * Compressor Transfer Function: hard-knee with color  
        */
        namespace Sidechain
        {
            graph Processor (float initialThreshold,
                        float initialRatio,
                        float initialColorHeight,
                        float initialColorWidth,
                        float initialAttack,
                        float initialRelease,
                        float initialNonlinearity)
            {
                input stream SampleType in;
                output stream SampleType out;
            
                let
                {
                    detector = Abs::Processor;
                    ballistics = BallisticsFilter::Processor(initialAttack, initialRelease);
                    ctf = CTF::Processor(initialThreshold, initialRatio, initialColorHeight, initialColorWidth);
                }
            
                connection
                {
                    in -> detector.in;
                    detector.out -> ballistics.in;
                    ballistics.out -> ctf.in;
                    ctf.out -> out;
                }
            }
        }

    } //namespace HighLevel

    /** Common Processors that wrap High-Level Processors*/
    namespace Common
    {
        /** Set the volume in dB via VA::SmoothedParameter */
        namespace Volume
        {
            graph Processor (float initialVolume, float slewRateSeconds = 0.1f, int initialPattern = -1)
            {
                input stream SampleType in;
                output stream SampleType out;
        
                input
                {
                    autoVolume.volumeIn;
                    autoVolume.parameterIn;
                }
        
                let
                {
                    autoVolume = Internal::AutoVolume::Processor (initialVolume, initialPattern);

                    smoothedGain = SmoothedParameter::Processor (initialVolume, slewRateSeconds,  1);
                    multiplier = Multiplier::Processor;
                }
        
                connection
                {
                    in -> multiplier.in1;

                    autoVolume.volumeOut -> smoothedGain.parameterIn;
                    smoothedGain.out -> multiplier.in2;

                    multiplier.out -> out;
                }
            }
        }
        
        /** Mix two signals 

            out << in2 when c.mix = 100.f
        */
        namespace Mixer
        {   
            struct Coeffs
            {
                SampleType t;
                float mix;
            }
        
            void update (Coeffs& c, float mix)
            {
                c.t = SampleType (mix) * SampleType (1.0/100.0);
                c.mix = mix;
            }
        
            SampleType process (SampleType in1, SampleType in2, Coeffs& c)
            {
                if (c.mix == 0.f)
                    return in1;
                else if (c.mix == 100.f)
                    return in2;
                else
                    return vlerp (in1, in2, c.t);
            }
        
            processor Processor (float initialMix = 100.f)
            {
                input stream SampleType in1, in2;
                output stream SampleType out;
        
                input event float mixIn [[ name: "Mix", min: 0, max: 100, init: initialMix, unit: "%" ]];
        
                event mixIn (float v) { mix = v; recalc = true; }
        
                float mix = initialMix;
                bool recalc = true;
        
                void run()
                {   
                    Coeffs c;
        
                    let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
        
                    loop
                    {
                        if (recalc)
                        {
                            recalc = false;
        
                            c.update (mix);
                        }
        
                        loop (updateIntervalSamples)
                        {
                            out << process (in1, in2, c);
        
                            advance();
                        }
                    }
                }
            }
        }
    } //namespace Common

/*==============================================================================
High-Level Helper Processors
==============================================================================*/

    /** Internal Processors made for 'VA::HighLevel' and 'VA::Common'*/
    namespace Internal
    {
        namespace OnepoleC_Lan 
        {
            graph Processor (float initialNonlinearity = 0.f)
            {
                input stream SampleType in, Lin;
                output stream SampleType highpassOut, lowpassOut;
        
                input
                {
                    L.nonlinearityIn;
                    L.resetIn;
                }

                let
                {
                    L = LanADAA::Processor (initialNonlinearity);
                    onepoleC = OnepoleC::Processor;
                }
        
                connection
                {
                    in -> onepoleC.in;

                    Lin -> L.in;
                    L.Omega -> onepoleC.Omega;

                    onepoleC.highpassOut -> highpassOut;
                    onepoleC.lowpassOut -> lowpassOut;
                }
            }
        }    

        //==============================================================================
        /** Automatic output volume compensation for VA::HighLevel Processors 
    
        pattern:
        - 0: for use with OnepoleC_Lan and the nonlinearity parameter
        */
        namespace AutoVolume
        {   
            struct Coeffs
            {
                bool auto;
                float[MAX_ARRAY_SIZE] pts;
            }
            
            struct State
            {
                float prevParam;
            }

            namespace Patterns
            {
                let None = -1;
                let OnepoleC_Lan = 0;
                let Size = 1;
            }

            namespace MinVolumes
            {
                let None = -12.f;
                let OnepoleC_Lan = -6.1f;
            }

            float processOnepoleC_Lan (float x, Coeffs& c)
            {
                    return c.pts.readLinearInterpolated (min (x * (float (c.pts.size - 1)/60.f), float (c.pts.size)));
            }
        
            void initializeOnepoleC_Lan (Coeffs& c)
            {
                    c.pts = float[8] ( -0.f, -1.f, -2.f, -3.5f, -3.5f, -3.5f, -3.5f, -3.5f);
            }

            processor Processor (float initialVolume = 0.f, int initialPattern = Patterns::None, bool initialAutoVolume = true)
            {
                input event float parameterIn; //auto mode only
                output event float volumeOut;

                input event float volumeIn [[name: "Volume", min: MinVolumes::OnepoleC_Lan, max: 0, init: initialVolume, step: 0.1, unit: "dB"]];

                Coeffs c;
                State s;

                void initialize (Coeffs& c)
                {
                    if const (initialPattern == Patterns::OnepoleC_Lan)
                        initializeOnepoleC_Lan (c);
                }

                float process (float x, Coeffs& c)
                {
                    if const (initialPattern == Patterns::OnepoleC_Lan)
                        return processOnepoleC_Lan (x, c);
                    else if const (initialPattern == Patterns::None)
                        return x;
                }

                event parameterIn (float v) 
                { 
                    s.prevParam = v;
                    if (c.auto)
                        volumeOut << process (v, c); 
                }

                event volumeIn (float v)
                {
                    if (v < (MinVolumes::OnepoleC_Lan + 0.1f))
                    {
                        volumeOut << process (s.prevParam, c);
                        c.auto = true;
                    }
                    else
                    {
                        c.auto = false;
                        volumeOut << v;
                    }
                }

                void init ()
                {
                    c.initialize();
                }

                void run() 
                { 
                    advance();
                }
            }
        }

    } //namespace Internal

    /** Tools for CLI debugging */
    namespace Debug
    {
        /** Switch between 2 signals 
        
            out << in2 when c.power == true
        */
        namespace Bypass
        {   
            struct Coeffs
            {
                bool power;
            }
        
            void update (Coeffs& c, float power)
            {
                c.power = bool (power); 
            }
        
            SampleType process (SampleType dry, SampleType wet, Coeffs& c)
            {
                if (c.power)
                    return wet;
                else 
                    return dry;
            }
        
            processor Processor (bool initialPower = true)
            {
                input stream SampleType dry, wet;
                output stream SampleType out;
        
                input event float powerIn [[ name: "Power", boolean, init: float (initialPower), text: "Off|On" ]];
        
                event powerIn (float v) { power = v; recalc = true; }
        
                float power = float (initialPower);
                bool recalc = true;
        
                void run()
                {   
                    Coeffs c;
        
                    let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
        
                    loop
                    {
                        if (recalc)
                        {
                            recalc = false;
        
                            c.update (power);
                        }
        
                        loop (updateIntervalSamples)
                        {
                            out << process (dry, wet, c);
        
                            advance();
                        }
                    }
                }
            }
        }

        /** Map DebugBufferType to SampleType (float32 mono to float64 stereo) */
        namespace DebugToSample
        {     
            SampleType process (DebugBufferType x)
            {
                return SampleType (x);
            }

            processor Processor()
            {
                input stream DebugBufferType in;
                output stream SampleType out;
        
                void run()
                {   
                    loop
                    {
                        out << process (in);

                        advance();
                    }
                }
            }
        }

        /** Map SampleType to DebugBufferType (float64 stereo to float32 mono) */
        namespace SampleToDebug
        {     
            DebugBufferType process (SampleType x)
            {
                return DebugBufferType (x.sum()/SampleType.size);
            }

            processor Processor()
            {
                input stream SampleType in;
                output stream DebugBufferType out;
        
                void run()
                {   
                    loop
                    {
                        out << process (in);

                        advance();
                    }
                }
            }
        }

    } //namespace Debug

/*==============================================================================
Effect-Specific Processors
==============================================================================*/
   
    /** Anhysteretic RL circuit cutoff 
    
        Notes:
        - optimized for use with OnepoleC
        - If sampling rate is 44.1kHz, use 2x oversampling
    */
    namespace LanADAA
    {   
        struct Coeffs
        {
            SampleType N;
        }
    
        void update (Coeffs& c, SampleType nonlinearity)
        {
            c.N = nonlinearity;
        }    
    
        SampleType f (SampleType x, Coeffs& c)
        {
            return vpowi (c.N * vabs (x) + SampleType (1.0), 2);
        }
    
        SampleType F1 (SampleType x, Coeffs& c)
        {
            return vpowi (x, 3) * vpowi (c.N, 2) * SampleType (1.0 / 3.0) + c.N * vpowi (x, 2) * vsgn (x) + x;
        }
    
        SampleType F2 (SampleType x, Coeffs& c)
        {
            return vpowi (x, 2) * (SampleType (0.5) + c.N * SampleType (1.0 / 3.0) * x * vsgn (x) + vpowi (c.N, 2) * SampleType (1.0 / 12.0) * vpowi (x, 2));
        }
    
        struct State
        {
            SampleType x_2;
            SampleType x_1;
            SampleType F2_1;
            SampleType F1_1;
        }
    
        void reset (State& s)
        {
            s.x_2 = ZERO;
            s.x_1 = ZERO;
            s.F2_1 = ZERO;
            s.F1_1 = ZERO;
        }

        SampleType processADAA2 (State& s, SampleType x, Coeffs& c)
        {
            //Find F1_0
            
            let x_0mx_1 = x - s.x_1;
            let F2_0 = F2 (x, c);
    
            let F1_0 = viflt (F1 (SampleType (0.5) * (x + s.x_1), c), 
                (F2_0 - s.F2_1) / x_0mx_1,
                vabs (x_0mx_1), ADAA_TOL);
    
            //Find f_0
            let x_0mx_2 = x - s.x_2;
    
            let xBar = SampleType (0.5) * (x + s.x_2);
            let delta = xBar - x;
    
            let f_0 = viflt (
                viflt (
                    F1 (SampleType (0.5) * (xBar + x), c),
                    (SampleType (2.0) / delta) * (F1 (xBar, c) + (F2_0 - F2 (xBar, c)) / delta),
                    vabs (delta), ADAA_TOL
                ),
                (SampleType (2.0) / (x_0mx_2)) * (F1_0 - s.F1_1),
                vabs (x_0mx_2), ADAA_TOL
            );
    
            //update s
            s.x_2 = s.x_1;
            s.x_1 = x;
            s.F2_1 = F2_0;
            s.F1_1 = F1_0;
    
            return f_0;
        }
    
        SampleType processADAA1 (State& s, SampleType x, Coeffs& c)
        {
            //Find f_0
            let x_0mx_1 = x - s.x_1;
            let F1_0 = F1 (x, c);
    
            let f_0 = viflt (f (SampleType (0.5) * (x + s.x_1), c), 
                (F1_0 - s.F1_1) / x_0mx_1,
                vabs (x_0mx_1), ADAA_TOL);
    
            //update s
            s.x_1 = x;
            s.F1_1 = F1_0;
    
            return f_0;
        }
    
        SampleType process (State& s, SampleType x, Coeffs& c)
        {
            return s.processADAA2 (x, c);
        }
    
        processor Processor (float initialNonlinearity = 0.f)
        {
            input stream SampleType in;
            output stream SampleType Omega;

            input event float nonlinearityIn [[ name: "Nonlinearity", min: 0, max: 275, init: initialNonlinearity ]];
            input event float resetIn [[ name: "Reset Internal State", hidden ]];

            event nonlinearityIn (float v) { nonlinearity = v; recalc = true; }
            event resetIn (float v) { s.reset(); }
            
            float nonlinearity = initialNonlinearity;
            bool recalc = true;

            State s;

            void run()
            {
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (nonlinearity);
                        s.reset();
                    }

                    loop (updateIntervalSamples)
                    {
                        Omega << (SampleType (twoPi - 1) + s.process (in, c));

                        advance();
                    }
                }
            }
        }
    }

    /** A compressor transfer function (CTF) with color
        
        Notes:
        - Algebraic bell-shaped function (derivative of a sigmoidal function arctan) used for color
        - See https://ocw.mit.edu/courses/mathematics/18-01sc-single-variable-calculus-fall-2010/1.-differentiation/part-falseStatement-implicit-differentiation-and-inverse-functions/session-15-implicit-differentiation-and-inverse-functions/MIT18_01SCF10_Ses15b.pdf
        - See https://blog.audio-tk.com/2015/09/08/audio-toolkit-additional-gain-functions/
    */
    namespace CTF
    {
        struct Coeffs 
        {
            SampleType thr;
            SampleType divR;
            SampleType height;
            SampleType divWidth; 
        }
    
        void update (Coeffs& c, float threshold, float ratio, float colorHeight, float colorWidth) 
        {
            c.thr = SampleType (threshold);
            c.divR = SampleType (1.0) / SampleType (ratio);
            c.height = SampleType (colorHeight);
            c.divWidth = SampleType (1.0) / SampleType (colorWidth);
        }
    
        SampleType process (SampleType x, Coeffs& c) 
        {
            const SampleType xdB = vgainTodB(x);

            const SampleType xdBmthr = xdB - c.thr;
            const SampleType temp = c.divWidth * (xdBmthr);
            const SampleType color = c.height / (SampleType(1.0) + temp * temp);
            
            let ydB = vifgt (c.thr + (xdBmthr) * c.divR + color, xdB + color, xdB, c.thr);

            return vdBtoGain(ydB) / x;
        }

        processor Processor(float initialThreshold = -20,
                            float initialRatio = 5,
                            float initialColorHeight = 5,
                            float initialColorWidth = 3)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event
            {
                float thresholdIn [[ name: "Threshold", min: -60.f, max: 0.f, init: initialThreshold, unit: "dB" ]];
                float ratioIn [[ name: "Ratio", min: 1.f, max: 100.f, init: initialRatio ]];
                float colorHeightIn [[ name: "Color Height", min: -12.f, max: 12.f, init: initialColorHeight, unit: "dB" ]];
                float colorWidthIn [[ name: "Color Width", min: -12.f, max: 12.f, init: initialColorWidth, unit: "dB" ]];
            }

            event thresholdIn (float v) { threshold = v; recalc = true; }
            event ratioIn (float v) { ratio = v; recalc = true; }
            event colorHeightIn (float v) { colorHeight = v; recalc = true; }
            event colorWidthIn (float v) { colorWidth = v; recalc = true; }

            float threshold = initialThreshold;
            float ratio = initialRatio;
            float colorHeight = initialColorHeight;
            float colorWidth = initialColorWidth;
            bool recalc = true;

            void run()
            {
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
            
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (threshold, ratio, colorHeight, colorWidth);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (in, c);
    
                        advance();
                    }
                }
            }
        }
    }

/** Nonlinear branching cutoff for making a nonlinear ballistics filter */
    // namespace BranchingCutoffFK
    // {
    //     struct Coeffs 
    //     {
    //         Lan::Coeffs attack;
    //         Lan::Coeffs release;
    //     }

    //     void update (Coeffs& c, MonoType attack, MonoType release, MonoType nonlinearity) 
    //     {
    //         Lan::updateStep(c.attack, attack, nonlinearity);
    //         Lan::updateStep(c.release, release, nonlinearity);
    //     }

    //     SampleType process (SampleType x, SampleType y, Coeffs& c) 
    //     {
    //         return x > y ? Lan::process(x, c.attack) : Lan::process(x, c.release);   
    //     }

    //     processor Processor(MonoType initialAttack,
    //                         MonoType initialRelease,
    //                         MonoType initialNonlinearity)
    //     {
    //         input stream SampleType x, y;
    //         output stream SampleType L;
    
    //         MonoType attack = initialAttack;
    //         MonoType release = initialRelease;
    //         MonoType nonlinearity = initialNonlinearity;
    //         bool recalc = true;
    
    //         void run()
    //         {
    //             Coeffs c;

                // let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
    
    //             loop
    //             {
    //                 if (recalc)
    //                 {
    //                     recalc = false;
    
    //                     c.update(attack, release, nonlinearity);
    //                 }
    
    //                 loop (updateIntervalSamples)
    //                 {
    //                     L << process(x, y, c);
    
    //                     advance();
    //                 }
    //             }
    //         }
    //     }
    // }

/** Modulating low pass with two different cutoffs for rising and falling input */
    namespace BallisticsFilter
    {
        graph Processor (float initialAttack,
                    float initialRelease)
        {
            input stream SampleType in;
            output stream SampleType out;
        
            let
            {
                onepole = Onepole::Processor;
                branchingCutoff = BranchingCutoff::Processor(initialAttack, initialRelease);
            }
        
            connection
            {
                in -> onepole.in;

                in -> branchingCutoff.x;
                onepole.out -> [1] -> branchingCutoff.y;

                branchingCutoff.Omega -> onepole.Omega;
                
                onepole.out -> out;
            }
        }
    }

/*==============================================================================
Nonlinear TPT Filter Processors
==============================================================================*/

    /** Onepole modified for cutoff modulation via an input stream
        
        Oversampling recommendations differ depending on modulation input
    */
    namespace OnepoleC
    {   
        processor Processor (int cutoffMode = 0)
        {
            input stream SampleType in;
            input stream SampleType Omega; //angular cutoff; must be > 0; oversample x2; use for any cutoffs
            input stream SampleType G; //integrator input gain; do not oversample; use for low cutoffs
            output stream SampleType lowpassOut, highpassOut;

            void run()
            {   
                Onepole::State s;
                Onepole::Coeffs c;

                let Tdiv2 = SampleType (processor.period * 0.5);

                loop
                {
                    if const (cutoffMode == 0)
                    {
                        let temp = Omega * Tdiv2; 
                        c.G = temp / (SampleType (1.0) + temp);
                    }
                    else 
                        c.G = G;

                    let y = Onepole::process (s, in, c);

                    lowpassOut << y[0];
                    highpassOut << y[1];

                    advance();
                }
            }
        }
    }

    /** Onepole modified for state variable saturation

        Notes:
        - 2x oversampling recommended
    */
    namespace OnepoleS
    {   
        struct Coeffs
        {
            SampleType b;
        }

        void update (Coeffs& c, float drive)
        {
            c.b = soul::dBtoGain (drive);
        }

        SampleType[2] process (Onepole::State& s, SampleType x, Coeffs& c)
        {
            let v = (x - s.s);
            let lpf = v + s.s;
            let hpf = x - lpf;

            s.s = SampleType (0.25) * vsigmoidCD (c.b * (v + lpf));

            return SampleType[2] (lpf, hpf);
        }

        processor Processor (float initialDrive)
        {
            input stream SampleType in;
            output stream SampleType lowpassOut, highpassOut;

            input event float driveIn [[ name: "Drive", min: 0, max: 20, init: initialDrive, text: "dB" ]];

            event driveIn (float v) { drive = v; recalc = true; }

            float drive = dBtoGain (initialDrive);
            bool recalc = true;

            void run()
            {   
                Onepole::State s;
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (drive);
                    }

                    loop (updateIntervalSamples)
                    {
                        let y = s.process (in, c);

                        lowpassOut << y[0];
                        highpassOut << y[1];

                        advance();
                    }
                }
            }
        }
    }

/*==============================================================================
Linear TPT Filter Processors
==============================================================================*/

    /** SOUL-VA's version of soul::filters::tpt::onepole  

        Notes:
        - If sampling rate is 44.1kHz, use 2x oversampling
        - Structure is more consistent with SVF and oversampling is used instead of prewarping
    */
    namespace Onepole
    {   
        struct Coeffs
        {
            SampleType G;
        }

        struct State
        {
            SampleType s;
        }

        SampleType[2] process (State& s, SampleType x, Coeffs& c)
        {
            let v = (x - s.s) * c.G;
            let lpf = v + s.s;
            let hpf = x - lpf;

            s.s = v + lpf;

            return SampleType[2] (lpf, hpf);
        }

        void update (Coeffs& c, float frequency, SampleType Tpi)
        {
            let g = Tpi * SampleType (frequency);
            c.G = g / (SampleType (1.0) + g);
        }

        processor Processor (float initialFrequency)
        {
            input stream SampleType in;
            output stream SampleType lowpassOut, highpassOut;

            input event float frequencyIn [[ name: "Frequency", min: 20, max: 20000, init: initialFrequency, text: "Hz" ]];

            event frequencyIn (float v) { frequency = v; recalc = true; }

            float frequency = float (initialFrequency);
            bool recalc = true;

            void run()
            {   
                State s;
                Coeffs c;

                let Tpi = SampleType (processor.period * pi);
                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (frequency, Tpi);
                    }

                    loop (updateIntervalSamples)
                    {
                        let y = s.process (in, c);

                        lowpassOut << y[0];
                        highpassOut << y[1];

                        advance();
                    }
                }
            }
        }
    }

    /** Mix outputs from Onepole to make more complicated frequency responses */
    namespace OnepoleMixer
    {   
        struct Coeffs
        {
            int m;
        }
    
        void update (Coeffs& c, float mode)
        {
            c.m = int (mode);
        }
    
        SampleType process (SampleType hpf, SampleType lpf, Coeffs& c)
        {
            if (c.m == 0)
                return hpf;
            else if (c.m == 1)
                return lpf;
            else
                return lpf - hpf;
        }
    
        processor Processor (int initialMode = 0)
        {
            input stream SampleType lowpassIn, highpassIn;
            output stream SampleType out;
    
            input event float modeIn [[ name: "Mode", min: 0, max: 2, init: initialMode, text: "HPF|LPF|APF" ]];

            static_assert ((initialMode >= 0 && initialMode <= 2), "initialMode must be in range [0, 2]");
    
            event modeIn (float v) { mode = v; recalc = true; }
    
            float mode = float (initialMode);
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (mode);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (highpassIn, lowpassIn, c);
    
                        advance();
                    }
                }
            }
        }
    }
    
    /** soul::tpt::svf modified for cutoff/resonance modulation via input streams
    
        2x oversampling recommended
    */  
    namespace SVF
    {
        struct Coeffs
        {
            SampleType a0;
            SampleType a;
            SampleType p;
        }

        struct State
        {
            SampleType[2] z;
        }

        SampleType[3] process (State& s, SampleType x, Coeffs& c)
        {
            let hpf = c.a0 * (x - c.p * s.z[0] - s.z[1]);
            let bpf = c.a * hpf + s.z[0];
            let lpf = c.a * bpf + s.z[1];

            s.z[0] = c.a * hpf + bpf;
            s.z[1] = c.a * bpf + lpf;

            return SampleType[3] (lpf, hpf, bpf);
        }

        processor Processor()
        {
            input stream SampleType in;
            input stream SampleType Omega; //angular cutoff; must be > 0
            input stream SampleType R; //resonance; must be > 0
            output stream SampleType lowpassOut, highpassOut, bandpassOut;

            void run()
            {
                State s;
                Coeffs c;

                let Tdiv2 = SampleType (processor.period * 0.5); 

                loop
                {
                    c.a = Omega * Tdiv2; //g
                    c.a0 = SampleType (1.0) / (SampleType (1.0) + SampleType (2.0) * R * c.a + c.a * c.a); //d
                    c.p = SampleType (2.0) * R + c.a; //g1

                    let y = s.process(in, c);

                    lowpassOut  << y[0];
                    highpassOut << y[1];
                    bandpassOut << y[2];
                    
                    advance();
                }
            }
        }
    }

/*==============================================================================
Common Internal Processors
==============================================================================*/

    /** Set a each vector element equal to a weighted average with all other elements */
    namespace StereoLink
    {   
        struct Coeffs
        {
            SampleType t;
            float stereoLink;
        }
    
        void update (Coeffs& c, float stereoLink)
        {
            c.t = SampleType (stereoLink *  (1.f / 200.f));
            c.stereoLink = stereoLink;
        }
    
        SampleType process (SampleType x, Coeffs& c)
        {
            if (c.stereoLink == 0.f)
                return x;
            else if (c.stereoLink == 100.f)
                return SampleType (x.sum()/x.size);
            else
            {
                let xp = SampleType (x[1] , x[0]);

                return vlerp (x, xp, c.t);
            }
        }
    
        processor Processor (float initialStereoLink = 0)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event float stereoLinkIn [[ name: "Stereo Link", min: 0, max: 100, init: initialStereoLink, unit: "%" ]];
            
            event stereoLinkIn (float v) { stereoLink = v; recalc = true; }

            float stereoLink = initialStereoLink;
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;
    
                let updateIntervalSamples = int ((processor.frequency/44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (stereoLink);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (in, c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** Set a each vector element equal to the average of its elements */
    namespace BinaryStereoLink
    {   
        struct Coeffs
        {
            bool stereoLink;
        }
    
        void update (Coeffs& c, float stereoLink)
        {
            c.stereoLink = bool (stereoLink);
        }
    
        SampleType process (SampleType x, Coeffs& c)
        {
            return (c.stereoLink ? SampleType (x.sum()/x.size) : x);
        }
    
        processor Processor (bool initialStereoLink = true)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event float stereoLinkIn [[ name: "Stereo Link", boolean, init: float (initialStereoLink), text: "Off|On" ]];
            
            event stereoLinkIn (float v) { stereoLink = v; recalc = true; }

            float stereoLink = float (initialStereoLink);
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;
    
                let updateIntervalSamples = int ((processor.frequency/44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (stereoLink);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (in, c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** Map input events directly to an output stream 

        Notes:
        - For parameters that need to be updated per sample
        - parameterIn requires an annotation (no default annotation)
        - modes:
            *0: linear scale  
            *1: dB scale 
    */   
    namespace UnsmoothedParameter
    { 
        processor Processor (float initialTarget = 0, int mode = 0)
        {
            input event float parameterIn;
            output stream SampleType out;
                
            SampleType target;

            void init()
            {
                target = SampleType (mode == 0 ? initialTarget : soul::dBtoGain (initialTarget));
            }

            event parameterIn (float v)
            {
                if const (mode == 0)
                    target = SampleType (v);
                else
                    target = SampleType (soul::dBtoGain (v));
            }
    
            void run()
            {
                loop
                {
                    out << target;

                    advance();
                }
            }
        }
    }

    /** Map input events to a smoothed output stream; Modified version of soul::gain::SmoothedGainParameter

        Notes:
        - parameterIn requires an annotation (no default annotation)
        - modes:
            *0: linear scale
            *1: dB scale
    */    
    namespace SmoothedParameter
    {
        processor Processor (float initialTarget, float slewRateSeconds = 0.1f, int mode = 0)
        {
            input event float parameterIn;
            output stream SampleType out;

            SampleType target;
            SampleType current;
            SampleType increment = SampleType (0);
            int remainingRampSamples = 0;
           
            SampleType divMaxDelta;

            void init()
            {
                current = SampleType (mode == 0 ? initialTarget : soul::dBtoGain (initialTarget));
                divMaxDelta = SampleType (slewRateSeconds / float (processor.period));
            }

            event parameterIn (float v)
            {
                if const (mode == 0)
                    target = v;
                else
                    target = vdBtoGain (v);

                remainingRampSamples = int (vclamp (1, inf32)::process (vabs (target - current) * divMaxDelta) [0]);
                increment = (target - current) / SampleType (remainingRampSamples);
            }

            void run()
            {
                loop
                {
                    if (remainingRampSamples != 0)
                    {
                        if (--remainingRampSamples == 0)
                            current = target;
                        else
                            current += increment;
                    }

                    out << current;

                    advance();
                }
            }
        }
    }

/*==============================================================================
Vector Operation Wrapper Processors
==============================================================================*/

    /** Processor wrapper of 'vabs' */
    namespace Abs
    {
        processor Processor()
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << vabs (in);

                    advance();
                }
            }
        }
    }

    namespace Multiplier
    {
        processor Processor
        {
            input stream SampleType in1, in2;
            output stream SampleType out;
    
            void run()
            {
                loop
                {
                    out << in1 * in2;
    
                    advance();
                }
            }
        }
    }

/*==============================================================================
Vector Operations
==============================================================================*/

    /** linear interpolation */
    SampleType vlerp (SampleType a, SampleType b, SampleType t)
    {
        return a + t * (b - a);
    }

    /** 'pow' for small integer exponents */
    SampleType vpowi (SampleType base, int exponent)
    {
        SampleType y = base;

        for (int i = 1; i < exponent; ++i)
            y *= base;

        return y;
    }

    /** 'pow' for SOUL vectors*/
    SampleType vpow (SampleType base, SampleType exponent)
    {
        return SampleType (pow (base[0], exponent[0]), pow (base[1], exponent[1]));
    }

    /** vectorized version of 
    
        return (a < b ? trueStatement : falseStatement);   
    */
    SampleType viflt (SampleType trueStatement, SampleType falseStatement, SampleType a, SampleType b)
    {
        return SampleType (a[0] < b[0] ? trueStatement [0] : falseStatement [0], a[1] < b[1] ? trueStatement [1] : falseStatement [1]);
    }
    
    /** vectorized version of 
        
        return (a > b ? trueStatement : falseStatement);   
    */
    SampleType vifgt (SampleType trueStatement, SampleType falseStatement, SampleType a, SampleType b)
    {
        return SampleType (a[0] > b[0] ? trueStatement [0] : falseStatement [0], a[1] > b[1] ? trueStatement [1] : falseStatement [1]);
    }

    /** clamp a value between low and high

        If 'low' = inf32 or 'high' = inf32, they will be optimized out at compile time
    */
    namespace vclamp (float low = float (-inf), float high = float (inf))
    {       

        let l = SampleType.primitiveType (low);
        let h = SampleType.primitiveType (high);

        SampleType process (SampleType x)
        {
            if const (low > -inf32 && high < inf32)
                return SampleType (clamp (x[0], l, h), clamp (x[1], l, h)); 
            else if const (low > -inf32)
                return SampleType (max (x[0], l), max (x[1], l));
            else
                return SampleType (min (x[0], h), min (x[1], h));
        }

        processor Processor ()
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << process (in);

                    advance();
                }
            }
        }
    }

    /** Convert gain to decibels and clamp results to greater than -100.0 dB */
    SampleType vgainTodB (SampleType x)
    {
        let temp = vclamp (N100dB, inf32)::process(x);

        return SampleType (20.0) * log10 (temp);
    }

    /** Convert decibels to gain and clamp inputs to greater than -100.0 dB */
    SampleType vdBtoGain (SampleType x)
    {
        let temp = vclamp (-100, inf32)::process(x);

        return vpow (SampleType (10.0), temp * SampleType (1.0 / 20.0));
    }

    /** Return 1 if x is positive, -1 if negative, and 0 otherwise */
    SampleType vsgn (SampleType x)
    {
        return SampleType (x[0] > 0 ? 1 : -1, x[1] > 0 ? 1 : -1);
        //SampleType (x > SampleType (0.0)) - SampleType (x < SampleType (0.0));
    }
    
    /** An continuously differentiable algebraic sigmoid function. 

            f(x) = x / sqrt (x^2 + 1) 
    
        A cheap 'tanh' approximation
    */
    SampleType vsigmoidCD (SampleType x)
    {
        return x / sqrt (x * x + SampleType (1.0));
    }

    /** Absolute value */
    SampleType vabs (SampleType x)
    {
        return SampleType (abs (x[0]), abs (x[1]));
    }

/*==============================================================================
Constants
==============================================================================*/

    using DebugBufferType = float;
    using SampleType = float64<2>; //also used internally as 'CoeffType'
    using MaskType = bool<SampleType.size>;

    let updateInterval = 128;
    let ADAA_TOL = SampleType (0.0000001);
    let N100dB = float (0.00001);
    let inf32 = float (inf);
    let ZERO = SampleType (0.0);
    let MAX_ARRAY_SIZE = 8;

    namespace filt = soul::filters (SampleType, SampleType.primitiveType, updateInterval);

} //namespace VA
