/** GNU GPLv3 License

    Copyright (C) 2021 ZheDeng
    TheZheDeng@gmail.com

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

/** SOUL-VA (https://github.com/thezhe/SOUL-VA)

    The following interface is nearly identical to soul::filters EXCEPT:
    - Each effect is a 'Processor' under 'VA::HighLevel'
    - No user defined types:
        *'SampleType' is float64<2>
        *The internal 'CoeffType' is float64<2>
        *Coefficient 'updateInterval' is every 128 samples at 44.1kHz 
        or scaled as needed (i.e. every 256 samples at 88.2kHz)
    - Expanded set of vector-friendly functions (see 'Vectorized Stateless Functions')
    - All effects are optimized for 44.1kHz/24-bit/stereo. 
    Higher sample rates and bit depths degrade performance 
    without guaranteed better quality! Any sampling rate beyond 96000
    is not supported.
*/

/** Task List

    Current Tasks:
    - double check LanADAA
    - BBD chorus/vibrato/flanger/delay/echo with NL moog ladder
    - ladder multimode LP

    Future Tasks:
    - initialization lists only for Processors and not namespaces
    - refactor snippets, fix adaa, namespace constants
    - SVF/OnepoleS/Compressor Components refactor and use
    - OnepoleS constant c.G value and use soul::dBtoGain for primitives 
    - state saturation
    - array vs vectors; if use array use .at()
    - fix all vlt and vgt to viflt and vifgt
*/

namespace VA 
{
/*==============================================================================
SOUL-VA Interface
==============================================================================*/

    /** High-level Processors made using the 'VA' and 'soul' namespaces */
    namespace HighLevel
    {   
        /** VA::LanADAA modulating VA::OnepoleC in all pass mode */
        namespace OnepoleC_Lan
        {
            graph Processor (float initialNonlinearity = 0.f, float initialStereoLink = 0.f)
            {
                input stream SampleType in;
                output stream SampleType out;
        
                input
                {
                    internal.nonlinearityIn;
                    stereoLink.stereoLinkIn;
                }
        
                let
                {
                    dcBlocker = filt::dc_blocker::Processor (5.f);
                    stereoLink = StereoLink::Processor (initialStereoLink);

                    internal = Internal::Processor (initialNonlinearity) * 2;

                    onepoleMixer = OnepoleMixer::Processor (2);
                }
        
                connection
                {
                    in -> dcBlocker -> stereoLink.in, internal.in;

                    stereoLink.out -> internal.Lin;

                    internal.highpassOut -> onepoleMixer.highpassIn;
                    internal.lowpassOut -> onepoleMixer.lowpassIn;
                    
                    onepoleMixer.out -> out;
                }
            }

            namespace Internal 
            {
                graph Processor (float initialNonlinearity = 0.f)
                {
                    input stream SampleType in, Lin;
                    output stream SampleType highpassOut, lowpassOut;
            
                    input
                    {
                        L.nonlinearityIn;
                    }

                    let
                    {
                        L = LanADAA::Processor (initialNonlinearity);
                        onepoleC = OnepoleC::Processor;
                    }
            
                    connection
                    {
                        in -> onepoleC.in;

                        Lin -> L.in;
                        L.Omega -> onepoleC.Omega;

                        onepoleC.highpassOut -> highpassOut;
                        onepoleC.lowpassOut -> lowpassOut;
                    }
                }
            }    
        }
        
        /** Delay line with a nonlinear ladder filter in feedback */
        namespace DelayLine_Ladder_NL
        {
            graph Processor(float initialDelay = 50, float initialFeedback = 0, float initialMix = 50.f)
            {
                input stream SampleType in;
                output stream SampleType out;
        
                input
                {
                    delayLine.delayIn;
                    mixer.mixIn;
                    feedback.mixIn feedbackIn;
                    ladder.cutoffIn;
                    ladder.resonanceIn;
                }
        
                let
                {
                    ladder = LadderFilter::Processor;
                    delayLine = DelayLine::Processor(initialDelay);
                    feedback = Common::Mixer::Processor(initialFeedback);
                    mixer = Common::Mixer::Processor(initialMix);
                }
        
                connection
                {
                    in -> mixer.in1, feedback.in1;
                    delayLine.out -> [1] -> mixer.in2, feedback.in2;
                    
                    feedback.out -> ladder.in;
                    ladder.y4 -> delayLine.in;

                    mixer.out -> out;
                }
            }
        }
        

    } //namespace HighLevel

    /** Common Processors that wrap High-Level Processors*/
    namespace Common
    {
        /** Set the volume in dB via VA::SmoothedParameter */
        namespace Volume
        {
            graph Processor (int Mode, float slewRateSeconds = 0.1f)
            {
                input stream SampleType in;
                output stream SampleType out;
        
                input
                {
                    autoVolume.volumeIn;
                    autoVolume.parameterIn;
                }
        
                let
                {
                    autoVolume = AutoVolume::Processor (Mode);

                    smoothedGain = SmoothedParameter::Processor (AutoVolume::ModeInfo(Mode)::InitialVolume, slewRateSeconds,  1);
                    multiplier = Multiplier::Processor;
                }
        
                connection
                {
                    in -> multiplier.in1;

                    autoVolume.volumeOut -> smoothedGain.parameterIn;
                    smoothedGain.out -> multiplier.in2;

                    multiplier.out -> out;
                }
            }
        }
        
        /** Mix two signals 

            out << in2 when c.mix = 100.f
        */
        namespace Mixer
        {   
            struct Coeffs
            {
                SampleType t;
                float mix;
            }
        
            void update (Coeffs& c, float mix)
            {
                c.t = SampleType (mix) * SampleType (1.0/100.0);
                c.mix = mix;
            }
        
            SampleType process (SampleType in1, SampleType in2, const Coeffs& c)
            {
                if (c.mix == 0.f)
                    return in1;
                else if (c.mix == 100.f)
                    return in2;
                else
                    return vlerp (in1, in2, c.t);
            }
        
            processor Processor (float initialMix = 100.f)
            {
                input stream SampleType in1, in2;
                output stream SampleType out;
        
                input event float mixIn [[ name: "Mix", min: 0, max: 100, init: initialMix, unit: "%" ]];
        
                event mixIn (float v) { mix = v; recalc = true; }
        
                float mix = initialMix;
                bool recalc = true;
        
                void run()
                {   
                    Coeffs c;
        
                    let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
        
                    loop
                    {
                        if (recalc)
                        {
                            recalc = false;
        
                            c.update (mix);
                        }
        
                        loop (updateIntervalSamples)
                        {
                            out << process (in1, in2, c);
        
                            advance();
                        }
                    }
                }
            }
        }
    } //namespace Common

    /** Tools for CLI debugging */
    namespace Debug
    {
        /** Switch between 2 signals 
        
            out << in2 when c.power == true
        */
        namespace Bypass
        {   
            struct Coeffs
            {
                bool power;
            }
        
            void update (Coeffs& c, float power)
            {
                c.power = bool (power); 
            }
        
            SampleType process (SampleType dry, SampleType wet, const Coeffs& c)
            {
                if (c.power)
                    return wet;
                else 
                    return dry;
            }
        
            processor Processor (bool initialPower = true)
            {
                input stream SampleType dry, wet;
                output stream SampleType out;
        
                input event float powerIn [[ name: "Power", boolean, init: float (initialPower), text: "Off|On" ]];
        
                event powerIn (float v) { power = v; recalc = true; }
        
                float power = float (initialPower);
                bool recalc = true;
        
                void run()
                {   
                    Coeffs c;
        
                    let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
        
                    loop
                    {
                        if (recalc)
                        {
                            recalc = false;
        
                            c.update (power);
                        }
        
                        loop (updateIntervalSamples)
                        {
                            out << process (dry, wet, c);
        
                            advance();
                        }
                    }
                }
            }
        }

        /** Map DebugBufferType to SampleType (float32 mono to float64 stereo) */
        namespace DebugToSample
        {     
            SampleType process (DebugBufferType x)
            {
                return SampleType (x);
            }

            processor Processor()
            {
                input stream DebugBufferType in;
                output stream SampleType out;
        
                void run()
                {   
                    loop
                    {
                        out << process (in);

                        advance();
                    }
                }
            }
        }

        /** Map SampleType to DebugBufferType (float64 stereo to float32 mono) */
        namespace SampleToDebug
        {     
            DebugBufferType process (SampleType x)
            {
                return DebugBufferType (x.sum()/SampleType.size);
            }

            processor Processor()
            {
                input stream SampleType in;
                output stream DebugBufferType out;
        
                void run()
                {   
                    loop
                    {
                        out << process (in);

                        advance();
                    }
                }
            }
        }

    } //namespace Debug

/*==============================================================================
Effect-Specific Stateful Processors
==============================================================================*/
    
    /** Automatic/manual output volume compensation for VA::HighLevel Processors 

        pattern:
        - 0: for use with OnepoleC_Lan and the nonlinearity parameter
    */
    namespace AutoVolume
    {   
        struct State
        {
            float prevVol;
            float prevParam;
        }

        namespace Modes
        {
            let None = 0;
            let OnepoleC_Lan = 1;
            let NumModes = 2;
        }

        namespace ModeInfo (int Mode = Modes::None)
        {
           // static_assert ((Mode < NumModes && Mod), "Auto Volume Mode must be less than Modes::NumModes.");

            let MaxVolume = (Mode == Modes::None ? 12.f : 0.f);
            let MinVolume = (Mode == Modes::None ? -12.f : -6.1f);
            let InitialVolume = (Mode == Modes::None ? 0.f : MinVolume);
            let MinManualVolume = (Mode == Modes::None ? -inf : MinVolume + 0.1f);
            let PtsSize = (Mode == Modes::None ? 1 : 4);
            let Pts = (Mode == Modes::None ? float[PtsSize] (0) : float[PtsSize] (-0.f, -1.f, -2.f, -3.5f));

            float process (float x, float[] pts)
            {
                if const (Mode == Modes::None)
                    return x;
                else if const (Mode == Modes::OnepoleC_Lan)
                    return pts.readLinearInterpolated (min (x * 0.1f, 3.f));
            }
        }

        processor Processor (int Mode = Modes::None)
        {
            input event float parameterIn; //auto mode only
            output event float volumeOut;

            input event float volumeIn [[name: "Volume", min: ModeInfo(Mode)::MinVolume, max: ModeInfo(Mode)::MaxVolume, init: ModeInfo(Mode)::InitialVolume, step: 0.1, unit: "dB"]];

            namespace M = ModeInfo(Mode);
            
            let pts = M::Pts;
            State s;

            float process (float x)
            {
                return M::process (x, pts);
            }

            event parameterIn (float v) 
            { 
                s.prevParam = v;

                if (s.prevVol < M::MinManualVolume)
                    volumeOut << process (s.prevParam); 
            }

            event volumeIn (float v)
            {
                s.prevVol = v;
                
                if (v < M::MinManualVolume)
                    volumeOut << process (s.prevParam);
                else
                    volumeOut << v;
            }

            void run() 
            { 
                advance();
            }
        }
    }
    
    /** Map input events to a smoothed output stream; Modified version of soul::gain::SmoothedGainParameter

        Notes:
        - parameterIn requires an annotation (no default annotation)
        - modes:
            *0: linear scale
            *1: dB scale
    */    
    namespace SmoothedParameter
    {
        processor Processor (float initialTarget, float slewRateSeconds = 0.1f, int mode = 0)
        {
            input event float parameterIn;
            output stream SampleType out;

            SampleType target;
            SampleType current;
            SampleType increment = SampleType (0);
            int remainingRampSamples = 0;
           
            SampleType divMaxDelta;

            void init()
            {
                current = SampleType (mode == 0 ? initialTarget : soul::dBtoGain (initialTarget));
                divMaxDelta = SampleType (slewRateSeconds / float (processor.period));
            }

            event parameterIn (float v)
            {
                if const (mode == 0)
                    target = v;
                else
                    target = vdBtoGain (v);

                remainingRampSamples = int (vclamp (1, inf32)::process (vabs (target - current) * divMaxDelta) [0]);
                increment = (target - current) / SampleType (remainingRampSamples);
            }

            void run()
            {
                loop
                {
                    if (remainingRampSamples != 0)
                    {
                        if (--remainingRampSamples == 0)
                            current = target;
                        else
                            current += increment;
                    }

                    out << current;

                    advance();
                }
            }
        }
    }

    /** OnepoleC with differing cutoff depending on rising/falling output relative to stored output (feedback)*/
    namespace BallisticsFilter_Lan
    {
        graph Processor (float initialAttackNonlinearity,
                        float initialAttack,
                        float initialReleaseNonlinearity,
                        float initialRelease)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                branchingCutoff.attackIn;
                branchingCutoff.attackNonlinearityIn;
                branchingCutoff.releaseIn;
                branchingCutoff.releaseNonlinearityIn;
            }
    
            let
            {
                branchingCutoff = BranchingCutoff_Lan::Processor (initialAttack, initialAttackNonlinearity, initialRelease, initialReleaseNonlinearity);
                onepoleC = OnepoleC::Processor;
            }
    
            connection
            {
                in -> onepoleC.in;

                onepoleC.lowpassOut -> [1] -> branchingCutoff.x;
                onepoleC.lowpassOut -> [2] -> branchingCutoff.y;
                branchingCutoff.Omega -> onepoleC.Omega;

                onepoleC.lowpassOut -> out;
            }
        }
    }
    
    /** Nonlinear branching cutoff for making a nonlinear ballistics filter */
    namespace BranchingCutoff_Lan
    {
        struct Coeffs 
        {
            Lan::Coeffs attack;
            Lan::Coeffs release;
        }

        void update (Coeffs& c, float attack, float attackNonlinearity, float release, float releaseNonlinearity) 
        {
            Lan::update (c.attack, attackNonlinearity, attack);
            Lan::update (c.release, releaseNonlinearity, release);
        }

        SampleType process (SampleType x, SampleType y, const Coeffs& c) 
        {
            return vifgt (Lan::process (x, c.attack), Lan::process(x, c.release), x, y);  
        }

        processor Processor(float initialAttackNonlinearity,
                            float initialAttack,
                            float initialReleaseNonlinearity,
                            float initialRelease)
        {
            input stream SampleType x, y;
            output stream SampleType Omega;
    
            input event
            { 
                float attackIn [[ name: "Attack", min: 1, max: 200, init: initialAttack, unit: "ms", step: 1 ]];
                float attackNonlinearityIn [[ name: "Attack Nonlinearity", min: 0, max: 1000, init: initialAttackNonlinearity, step: 1 ]];
                float releaseIn [[ name: "Release", min: 1, max: 500, init: initialRelease, unit: "ms", step: 1 ]];
                float releaseNonlinearityIn [[ name: "Release Nonlinearity", min: 0, max: 1000, init: initialReleaseNonlinearity, step: 1]];
            }

            event attackIn (float v) { attack = v; recalc = true; }
            event attackNonlinearityIn (float v) { attackNonlinearity = v; recalc = true; }
            event releaseIn (float v) { release = v; recalc = true; }
            event releaseNonlinearityIn (float v) { releaseNonlinearity = v; recalc = true; }

            float attack = initialAttack;
            float attackNonlinearity = initialAttackNonlinearity;
            float release = initialRelease;
            float releaseNonlinearity = initialReleaseNonlinearity;
            bool recalc = true;
    
            void run()
            {
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
    
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (attack, attackNonlinearity, release, releaseNonlinearity);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        Omega << process(x, y, c);
    
                        advance();
                    }
                }
            }
        }
    }

/*==============================================================================
Nonlinear Stateful Processors
==============================================================================*/

    /** Onepole modified for cutoff modulation via an input stream
        
        - 2x oversampling reccomended if using as a frequency effect
    */
    namespace OnepoleC
    {   
        processor Processor
        {
            input stream SampleType in;
            input stream SampleType Omega;
            output stream SampleType lowpassOut, highpassOut;

            void run()
            {   
                Onepole::State s;
                Onepole::Coeffs c;

                let Tdiv2 = SampleType (processor.period * 0.5);

                loop
                {
                    let temp = Omega * Tdiv2; 
                    c.G = temp / (SampleType (1.0) + temp);

                    let y = Onepole::process (s, in, c);

                    lowpassOut << y[0];
                    highpassOut << y[1];

                    advance();
                }
            }
        }
    }

/*==============================================================================
Linear Stateful Processors
==============================================================================*/

    /** SOUL-VA's version of soul::filters::tpt::onepole  

        Notes:
        - If sampling rate is 44.1kHz, use 2x oversampling
        - Structure is more consistent with SVF and oversampling is used instead of prewarping
    */
    namespace Onepole
    {   
        struct Coeffs
        {
            SampleType G;
        }

        struct State
        {
            SampleType s;
        }

        SampleType[2] process (State& s, SampleType x, const Coeffs& c)
        {
            let v = (x - s.s) * c.G;
            let lpf = v + s.s;
            let hpf = x - lpf;

            s.s = v + lpf;

            return SampleType[2] (lpf, hpf);
        }

        void update (Coeffs& c, float frequency, SampleType Tpi)
        {
            let g = Tpi * SampleType (frequency);
            c.G = g / (SampleType (1.0) + g);
        }

        processor Processor (float initialFrequency)
        {
            input stream SampleType in;
            output stream SampleType lowpassOut, highpassOut;

            input event float frequencyIn [[ name: "Frequency", min: 20, max: 20000, init: initialFrequency, text: "Hz" ]];

            event frequencyIn (float v) { frequency = v; recalc = true; }

            float frequency = float (initialFrequency);
            bool recalc = true;

            void run()
            {   
                State s;
                Coeffs c;

                let Tpi = SampleType (processor.period * pi);
                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (frequency, Tpi);
                    }

                    loop (updateIntervalSamples)
                    {
                        let y = s.process (in, c);

                        lowpassOut << y[0];
                        highpassOut << y[1];

                        advance();
                    }
                }
            }
        }
    }

    /** Mix outputs from Onepole to make more complicated frequency responses */
    namespace OnepoleMixer
    {   
        struct Coeffs
        {
            int m;
        }
    
        void update (Coeffs& c, float mode)
        {
            c.m = int (mode);
        }
    
        SampleType process (SampleType hpf, SampleType lpf, const Coeffs& c)
        {
            if (c.m == 0)
                return hpf;
            else if (c.m == 1)
                return lpf;
            else
                return lpf - hpf;
        }
    
        processor Processor (int initialMode = 0)
        {
            input stream SampleType lowpassIn, highpassIn;
            output stream SampleType out;
    
            input event float modeIn [[ name: "Mode", min: 0, max: 2, init: initialMode, text: "HPF|LPF|APF" ]];

            static_assert ((initialMode >= 0 && initialMode <= 2), "initialMode must be in range [0, 2]");
    
            event modeIn (float v) { mode = v; recalc = true; }
    
            float mode = float (initialMode);
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (mode);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (highpassIn, lowpassIn, c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** Modified version of https://soul.dev/lab/?id=Delay */
    namespace DelayLine
    {   
        processor Processor (float initialDelayMs = 50)
        {
            input stream SampleType in;
            input stream float modIn;
            output stream SampleType out;

            input event float delayIn [[ name: "Delay", min: 0, max: 1000, init: initialDelayMs, unit: "ms", step: 1 ]];

            event delayIn (float v) { delayMs = v; recalc = true; }
            
            //state
            wrap<MAX_BUFFER_SIZE> readPos, writePos;
            SampleType[MAX_BUFFER_SIZE] buffer;

            //coeffs
            float delayMs = initialDelayMs;
            bool recalc = true;
    
            void run()
            {   
                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
                
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        let delaySamples = max (1, int (processor.frequency * (delayMs * (1.f/1000.0f))));
                        readPos = wrap<MAX_BUFFER_SIZE> (writePos - delaySamples);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        buffer.at(writePos) = in;
                
                        out << buffer.readLinearInterpolated (float (readPos) + modIn);

                        ++readPos;
                        ++writePos;

                        advance();
                    }
                }
            }
        }
    }
    
    /** 4 Pole Ladder Filter 

        Notes:
        - If sampling rate is 44.1kHz, use 2x oversampling
    */
    namespace LadderFilter
    {   
        struct Coeffs
        {
            SampleType g;
            SampleType k;
        }
    
        void update (Coeffs& c, float cutoff, float resonance, SampleType Tpi)
        {
            let gOnepole = SampleType (cutoff) * Tpi;
            c.g = gOnepole / (ONE + gOnepole);
            c.k = SampleType (resonance);
        }
        
        struct State
        {
            SampleType[4] s;
        }
    
        SampleType[5] process (State& s, SampleType x, const Coeffs& c)
        {
            let G = vpowi (c.g, 4);
            let S = vpowi (c.g, 3) * s.s.at(0) + vpowi (c.g, 2) * s.s.at(1) + c.g * s.s.at(2) + s.s.at(3);

            SampleType[5] y;

            y[0] = (x - c.k * S) / (ONE + c.k * G); //u

            //4x LPF
            for (int i = 0; i < 4; ++i)
            {
                let v = (y.at(i) - s.s.at(i)) * c.g;
                y.at(i + 1) = v  + s.s.at(i);
                s.s.at(i) = vsigmoidCD_S (v + y.at(i +1), SampleType(1.0));
            }
            
            return y;
        }
    
        processor Processor (float initialCutoff = 1000, float initialResonance = 1)
        {
            input stream SampleType in;
            output stream SampleType y0, y1, y2, y3, y4;

            input event float cutoffIn [[ name: "Cutoff", min: MIN_CUTOFF_HZ, max: MAX_CUTOFF_HZ, init: initialCutoff, unit: "Hz", step: 1 ]];
            input event float resonanceIn [[ name: "Resonance", min: 1, max: 10, init: initialResonance ]];
            
            event cutoffIn (float v) { cutoff = v; recalc = true; }
            event resonanceIn (float v) { resonance = v; recalc = true; }

            float cutoff = initialCutoff;
            float resonance = initialResonance;
            bool recalc = true;
    
            void run()
            {   
                State s;
                Coeffs c;
    
                let Tpi = SampleType (processor.period * pi);
                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
    
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (cutoff, resonance, Tpi);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        let y = s.process (in, c);

                        y0 << y[0];
                        y1 << y[1];
                        y2 << y[2];
                        y3 << y[3];
                        y4 << y[4];
    
                        advance();
                    }
                }
            }
        }
    }
    
/*==============================================================================
Vectorized Stateless Function Wrapper Processors
==============================================================================*/

    /** A standard CTF (compressor transfer function)

        See: https://www.dropbox.com/s/cjq4t08u6pqkaas/ADC17FiftyShadesDistortion.zip?dl=0&file_subpath=%2FCode%2FDynamicsCompressor.cpp
    */
    namespace CTF
    {
        struct Coeffs 
        {
            SampleType threshold;
            SampleType ratio1;
            SampleType ratio2;
        }
    
        void update (Coeffs& c, float threshold, float ratio1, float ratio2) 
        {
            c.threshold = SampleType (threshold);
            c.ratio1 = SampleType (ratio1);
            c.ratio2 = SampleType (ratio2);
        }
    
        SampleType process (SampleType x, const Coeffs& c) 
        {
            return vCTF (x, c.threshold, c.ratio1, c.ratio2);
        }

        processor Processor(float initialThreshold = -20.f, float initialRatio1 = 2.f, float initialRatio2 = 2.f)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event float thresholdIn [[ name: "Threshold", min: -60.f, max: 0.f, init: initialThreshold, unit: "dB" ]];
            input event float ratio1In [[ name: "Ratio 1", min: 0.5f, max: 50.f, init: initialRatio1 ]];
            input event float ratio2In [[ name: "Ratio 2", min: 0.5f, max: 50.f, init: initialRatio2 ]];

            event thresholdIn (float v) { threshold = v; recalc = true; }
            event ratio1In (float v) { ratio1 = v; recalc = true; }
            event ratio2In (float v) { ratio2 = v; recalc = true; }

            float threshold = initialThreshold;
            float ratio1 = initialRatio1;
            float ratio2 = initialRatio2;
            bool recalc = true;

            void run()
            {
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
            
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (threshold, ratio1, ratio2);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (in, c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** A compressor transfer function (CTF) with color
        
        Notes:
        - Algebraic bell-shaped function (derivative of a sigmoidal function arctan) used for color
        - See https://ocw.mit.edu/courses/mathematics/18-01sc-single-variable-calculus-fall-2010/1.-differentiation/part-falseStatement-implicit-differentiation-and-inverse-functions/session-15-implicit-differentiation-and-inverse-functions/MIT18_01SCF10_Ses15b.pdf
        - See https://blog.audio-tk.com/2015/09/08/audio-toolkit-additional-gain-functions/
    */
    namespace CTF_Color
    {
        struct Coeffs 
        {
            SampleType threshold;
            SampleType ratio;
            SampleType height;
            SampleType width; 
        }
    
        void update (Coeffs& c, float threshold, float ratio, float colorHeight, float colorWidth) 
        {
            c.threshold = SampleType (threshold);
            c.ratio = SampleType (ratio);
            c.height = SampleType (colorHeight);
            c.width = SampleType (colorWidth);
        }
    
        SampleType process (SampleType x, const Coeffs& c) 
        {
            return vCTF_Color (x, c.threshold, c.ratio, c.height, c.width);
        }

        processor Processor(float initialThreshold = -20,
                            float initialRatio = 5,
                            float initialHeight = 5,
                            float initialWidth = 3)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event float thresholdIn [[ name: "Threshold", min: -60.f, max: 0.f, init: initialThreshold, unit: "dB" ]];
            input event float ratioIn [[ name: "Ratio", min: 1.f, max: 100.f, init: initialRatio ]];
            input event float heightIn [[ name: "Height", min: -12.f, max: 12.f, init: initialHeight, unit: "dB" ]];
            input event float widthIn [[ name: "Width", min: -12.f, max: 12.f, init: initialWidth, unit: "dB" ]];

            event thresholdIn (float v) { threshold = v; recalc = true; }
            event ratioIn (float v) { ratio = v; recalc = true; }
            event colorHeightIn (float v) { height = v; recalc = true; }
            event colorWidthIn (float v) { width = v; recalc = true; }

            float threshold = initialThreshold;
            float ratio = initialRatio;
            float height = initialHeight;
            float width = initialWidth;
            bool recalc = true;

            void run()
            {
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
            
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (threshold, ratio, height, width);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (in, c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** Set a each vector element equal to a weighted average using 'vlerp' */
    namespace StereoLink
    {   
        struct Coeffs
        {
            SampleType t;
            float stereoLink;
        }
    
        void update (Coeffs& c, float stereoLink)
        {
            c.t = SampleType (stereoLink *  (1.f / 200.f));
            c.stereoLink = stereoLink;
        }
    
        SampleType process (SampleType x, const Coeffs& c)
        {
            if (c.stereoLink == 0.f)
                return x;
            else if (c.stereoLink == 100.f)
                return SampleType (x.sum()/x.size);
            else
            {
                let xp = SampleType (x[1] , x[0]);

                return vlerp (x, xp, c.t);
            }
        }
    
        processor Processor (float initialStereoLink = 0)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event float stereoLinkIn [[ name: "Stereo Link", min: 0, max: 100, init: initialStereoLink, unit: "%" ]];
            
            event stereoLinkIn (float v) { stereoLink = v; recalc = true; }

            float stereoLink = initialStereoLink;
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;
    
                let updateIntervalSamples = int ((processor.frequency/44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (stereoLink);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (in, c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** 'vLan' with ADAA and a linear angular cutoff of 2pi
    
        Notes:
        - optimized for use with OnepoleC or modulating frequency domain filters
        - If sampling rate is 44.1kHz, use 2x oversampling
    */
    namespace LanADAA
    {   
        struct Coeffs
        {
            SampleType N;
        }
    
        void update (Coeffs& c, float nonlinearity)
        {
            c.N = SampleType (nonlinearity);
        }    
    
        SampleType f (SampleType x, const Coeffs& c)
        {
            return vLan (x, c.N);
        }
    
        SampleType F1 (SampleType x, const Coeffs& c)
        {
            return vpowi (x, 3) * vpowi (c.N, 2) * SampleType (1.0 / 3.0) + c.N * vpowi (x, 2) * vsgn (x) + x;
        }
    
        SampleType F2 (SampleType x, const Coeffs& c)
        {
            return vpowi (x, 2) * (SampleType (0.5) + c.N * SampleType (1.0 / 3.0) * x * vsgn (x) + vpowi (c.N, 2) * SampleType (1.0 / 12.0) * vpowi (x, 2));
        }
    
        struct State
        {
            SampleType x_2;
            SampleType x_1;
            SampleType F2_1;
            SampleType F1_1;
        }
    
        void reset (State& s)
        {
            s.x_2 = ZERO;
            s.x_1 = ZERO;
            s.F2_1 = ZERO;
            s.F1_1 = ZERO;
        }

        SampleType processADAA2 (State& s, SampleType x, const Coeffs& c)
        {
            //Find F1_0
            
            let x_0mx_1 = x - s.x_1;
            let F2_0 = F2 (x, c);
    
            let F1_0 = viflt (F1 (SampleType (0.5) * (x + s.x_1), c), 
                (F2_0 - s.F2_1) / x_0mx_1,
                vabs (x_0mx_1), ADAA_TOL);
    
            //Find f_0
            let x_0mx_2 = x - s.x_2;
    
            let xBar = SampleType (0.5) * (x + s.x_2);
            let delta = xBar - x;
    
            let f_0 = viflt (
                viflt (
                    F1 (SampleType (0.5) * (xBar + x), c),
                    (SampleType (2.0) / delta) * (F1 (xBar, c) + (F2_0 - F2 (xBar, c)) / delta),
                    vabs (delta), ADAA_TOL
                ),
                (SampleType (2.0) / (x_0mx_2)) * (F1_0 - s.F1_1),
                vabs (x_0mx_2), ADAA_TOL
            );
    
            //update s
            s.x_2 = s.x_1;
            s.x_1 = x;
            s.F2_1 = F2_0;
            s.F1_1 = F1_0;
    
            return f_0;
        }
    
        SampleType process (State& s, SampleType x, const Coeffs& c)
        {
            return s.processADAA2 (x, c);
        }
    
        processor Processor (float initialNonlinearity = 0.f)
        {
            input stream SampleType in;
            output stream SampleType Omega;

            input event float nonlinearityIn [[ name: "Nonlinearity", min: 0, max: 275, init: initialNonlinearity ]];

            event nonlinearityIn (float v) { nonlinearity = v; recalc = true; }
            
            float nonlinearity = initialNonlinearity;
            bool recalc = true;

            State s;

            void run()
            {
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (nonlinearity);
                        s.reset();
                    }

                    loop (updateIntervalSamples)
                    {
                        Omega << (SampleType (twoPi - 1) + s.process (in, c));

                        advance();
                    }
                }
            }
        }
    }

    /** 'VLan' Processor wrapper
    
        Notes:
        - optimized for use with step-reponse filters
    */
    namespace Lan
    {   
        struct Coeffs
        {
            SampleType N;
            SampleType bias;
        }
    
        void update (Coeffs& c, float nonlinearity, float tau)
        {
            c.N = SampleType (nonlinearity);
            c.bias = SampleType (1000.0) / SampleType (tau) - ONE;
        }    

        SampleType process (SampleType x, const Coeffs& c)
        {
            return c.bias + vLan (x, c.N);
        }
    
        processor Processor (float initialNonlinearity = 0.f, float initialTau = 20.f)
        {
            input stream SampleType in;
            output stream SampleType Omega;

            input event float nonlinearityIn [[ name: "Nonlinearity", min: 0, max: 275, init: initialNonlinearity, step: 1 ]];
            input event float tauIn [[ name: "Tau", min: 0, max: 500, init: initialTau, step: 1 ]];

            event nonlinearityIn (float v) { nonlinearity = v; recalc = true; }
            event tauIn (float v) { tau = v; recalc = true; }

            float tau = initialTau;
            float nonlinearity = initialNonlinearity;
            bool recalc = true;

            void run()
            {
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (nonlinearity, tau);
                    }

                    loop (updateIntervalSamples)
                    {
                        Omega << process (in, c);

                        advance();
                    }
                }
            }
        }
    }

    namespace Abs
    {
        processor Processor()
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << vabs (in);

                    advance();
                }
            }
        }
    }

    namespace Multiplier
    {
        processor Processor
        {
            input stream SampleType in1, in2;
            output stream SampleType out;
    
            void run()
            {
                loop
                {
                    out << in1 * in2;
    
                    advance();
                }
            }
        }
    }

/*==============================================================================
Vectorized Stateless Functions
==============================================================================*/

    SampleType vCTF_Color (SampleType x, SampleType thr, SampleType ratio, SampleType height, SampleType width)
    {
        let xdB = vgainTodB(x);
        let xdBmthr = xdB - thr;

        let color = height / (ONE + vpowi (xdBmthr * ONE/width, 2));
        let ydB = vifgt (thr + xdBmthr * ONE/ratio + color, xdB + color, xdB, thr);

        return vdBtoGain(ydB) / x;
    }

    SampleType vCTF (SampleType x, SampleType threshold, SampleType ratio1, SampleType ratio2)
    {
        let divRatio1m1 = ONE/ratio1 - ONE;
        let divRatio2m1 = ONE/ratio2 - ONE;
        let thrlin = vdBtoGain (threshold);

        let y = vifgt (vpow (x * (ONE/thrlin), divRatio1m1), vpow (x * (ONE/thrlin), divRatio2m1), x, thrlin);
        return vifgt (y, ONE, x, SampleType(0.001));
    }

    /** Cutoff (Omega) modulation from an anhysteretic first-order nonlinear inductor circuit
    
        The linear cutoff is 1. Add a bias if a different linear cutoff is desired
        ie:
        vLan(x, N) + bias
    */
    SampleType vLan (SampleType x, SampleType N)
    {
        return vpowi (N * vabs (x) + ONE, 2);
    }

    /** linear interpolation */
    SampleType vlerp (SampleType a, SampleType b, SampleType t)
    {
        return a + t * (b - a);
    }

    /** 'pow' for small integer exponents */
    SampleType vpowi (SampleType base, int exponent)
    {
        SampleType y = base;

        for (int i = 1; i < exponent; ++i)
            y *= base;

        return y;
    }

    /** 'pow' for SOUL vectors*/
    SampleType vpow (SampleType base, SampleType exponent)
    {
        return SampleType (pow (base[0], exponent[0]), pow (base[1], exponent[1]));
    }

    /** vectorized version of 
    
        return (a < b ? trueStatement : falseStatement);   
    */
    SampleType viflt (SampleType trueStatement, SampleType falseStatement, SampleType a, SampleType b)
    {
        return SampleType (a[0] < b[0] ? trueStatement [0] : falseStatement [0], a[1] < b[1] ? trueStatement [1] : falseStatement [1]);
    }
    
    /** vectorized version of 
        
        return (a > b ? trueStatement : falseStatement);   
    */
    SampleType vifgt (SampleType trueStatement, SampleType falseStatement, SampleType a, SampleType b)
    {
        return SampleType (a[0] > b[0] ? trueStatement [0] : falseStatement [0], a[1] > b[1] ? trueStatement [1] : falseStatement [1]);
    }

    /** clamp a value between low and high

        If 'low' = inf32 or 'high' = inf32, they will be optimized out at compile time
    */
    namespace vclamp (float low = float (-inf), float high = float (inf))
    {       

        let l = SampleType.primitiveType (low);
        let h = SampleType.primitiveType (high);

        SampleType process (SampleType x)
        {
            if const (low > -inf32 && high < inf32)
                return SampleType (clamp (x[0], l, h), clamp (x[1], l, h)); 
            else if const (low > -inf32)
                return SampleType (max (x[0], l), max (x[1], l));
            else
                return SampleType (min (x[0], h), min (x[1], h));
        }

        processor Processor ()
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << process (in);

                    advance();
                }
            }
        }
    }

    /** Convert gain to decibels and clamp results to greater than -100.0 dB */
    SampleType vgainTodB (SampleType x)
    {
        let temp = vclamp (N100dB, inf32)::process(x);

        return SampleType (20.0) * log10 (temp);
    }

    /** Convert decibels to gain and clamp inputs to greater than -100.0 dB */
    SampleType vdBtoGain (SampleType x)
    {
        let temp = vclamp (-100, inf32)::process(x);

        return vpow (SampleType (10.0), temp * SampleType (1.0 / 20.0));
    }

    /** Return 1 if x is positive, -1 if negative, and 0 otherwise */
    SampleType vsgn (SampleType x)
    {
        return SampleType (x[0] > 0 ? 1 : -1, x[1] > 0 ? 1 : -1);
        //SampleType (x > SampleType (0.0)) - SampleType (x < SampleType (0.0));
    }
    
    /** vsigmoidCD with a gain of 1 at the origin and drive (linear gain) of b, good for state saturation */
    SampleType vsigmoidCD_S (SampleType x, SampleType b)
    {
        return vsigmoidCD(b * x) * (ONE / b); 
    }

    /** An continuously differentiable algebraic sigmoid function. 

            f(x) = x / sqrt (x^2 + 1) 
    
        A cheap 'tanh' approximation
    */
    SampleType vsigmoidCD (SampleType x)
    {
        return x / sqrt (x * x + SampleType (1.0));
    }

    /** Absolute value */
    SampleType vabs (SampleType x)
    {
        return SampleType (abs (x[0]), abs (x[1]));
    }

/*==============================================================================
Constants
==============================================================================*/

    using DebugBufferType = float;
    using SampleType = float64<2>; //also used internally as 'CoeffType'

    let updateInterval = 128;
    
    let N100dB = float (0.00001);
    let inf32 = float (inf);

    let ADAA_TOL = SampleType (0.0000001);
    let ZERO = SampleType (0.0);
    let ONE = SampleType (1.0);
    let MAX_BUFFER_SIZE = 96000; //for arrays of SampleType
    let MAX_ARRAY_SIZE = 8; //for all other array
    let MAX_CUTOFF_HZ = 20000;
    let MIN_CUTOFF_HZ = 20;

    namespace filt = soul::filters (SampleType, SampleType.primitiveType, updateInterval);

} //namespace VA


namespace VA::Experimental
{
            /** A modified classical compressor sidechain
        
            3 sidechain blocks:
            - Detector: ideal rectifier
            - Envelope Filter: nonlinear ballistics filter based on Lan
            - Compressor Transfer Function: hard-knee with color  
        */
        // namespace DynamicsProcessor_Lan_Color
        // {
        //     graph Processor (float initialThreshold,
        //                     float initialRatio,
        //                     float initialColorHeight,
        //                     float initialColorWidth,
        //                     float initialAttack,
        //                     float initialRelease,
        //                     float initialNonlinearity)
        //     {
        //         input stream SampleType in;
        //         output stream SampleType out;
            
        //         input
        //         {
        //             ballisticsFilter.attackIn;
        //             ballisticsFilter.releaseIn;
        //             stereoLink.stereoLinkIn;
        //             ctf.thresholdIn;
        //             ctf.ratioIn;
        //             ctf.colorHeight;
        //             ctf.colorWidth;
        //         }

        //         let
        //         {
        //             detector = Abs::Processor;
        //             ballisticsFilter = BallisticsFilter_Lan::Processor (initialAttack, initialRelease);
        //             stereoLink = StereoLink::Processor;
        //             ctf = CTF_Color::Processor (initialThreshold, initialRatio, initialColorHeight, initialColorWidth);
        //         }
            
        //         connection
        //         {
        //             in -> detector.in;
        //             detector.out -> ballistics.in;
        //             ballistics.out -> stereoLinkIn;
        //             stereoLink.out -> ctf.in;
        //             ctf.out -> out;
        //         }
        //     }
        // }

        /** A modified downward compressor/ upward expander 
        
            3 sidechain blocks:
            - Detector: ideal rectifier
            - Envelope Filter: nonlinear ballistics filter based on Lan
            - Compressor Transfer Function: hard-knee 
        */
        // namespace DynamicsProcessor_Lan
        // {
        //     graph Processor (float initialAttack,
        //                     float initialAttackNonlinearity,
        //                     float initialRelease,
        //                     float initialReleaseNonlinearity,
        //                     float initialStereoLink,
        //                     float initialThreshold,
        //                     float initialRatio1,
        //                     float initialRatio2)
        //     {
        //         input stream SampleType in;
        //         output stream SampleType out;
            
        //         input
        //         {
        //             ballisticsFilter_Lan.attackIn;
        //             ballisticsFilter_Lan.attackNonlinearityIn;
        //             ballisticsFilter_Lan.releaseIn;
        //             ballisticsFilter_Lan.releaseNonlinearityIn;
        //             stereoLink.stereoLinkIn;
        //             ctf.thresholdIn;
        //             ctf.ratio1In;
        //             ctf.ratio2In;
        //         }

        //         let
        //         {
        //             abs_ = Abs::Processor;
        //             ballisticsFilter_Lan = BallisticsFilter_Lan::Processor (initialAttack, initialAttackNonlinearity, initialRelease, initialReleaseNonlinearity);
        //             stereoLink = StereoLink::Processor (initialStereoLink);
        //             ctf = CTF::Processor (initialThreshold, initialRatio1, initialRatio2);
        //             multiplier = Multiplier::Processor;
        //         }
            
        //         connection
        //         {
        //             in -> abs_.in, multiplier.in1;

        //             abs_.out -> ballisticsFilter_Lan.in;
        //             ballisticsFilter_Lan.out -> stereoLink.in;
        //             stereoLink.out -> ctf.in;
        //             ctf.out -> multiplier.in2;

        //             multiplier -> out;
        //         }
        //     }
        // }


    /** Onepole modified for state variable saturation

        Notes:
        - 2x oversampling recommended
    */
    namespace OnepoleS
    {   
        struct Coeffs
        {
            SampleType b;
        }

        void update (Coeffs& c, float drive)
        {
            c.b = soul::dBtoGain (drive);
        }

        SampleType[2] process (Onepole::State& s, SampleType x, const Coeffs& c)
        {
            let v = (x - s.s);
            let lpf = v + s.s;
            let hpf = x - lpf;

            s.s = SampleType (0.25) * vsigmoidCD (c.b * (v + lpf));

            return SampleType[2] (lpf, hpf);
        }

        processor Processor (float initialDrive)
        {
            input stream SampleType in;
            output stream SampleType lowpassOut, highpassOut;

            input event float driveIn [[ name: "Drive", min: 0, max: 20, init: initialDrive, text: "dB" ]];

            event driveIn (float v) { drive = v; recalc = true; }

            float drive = dBtoGain (initialDrive);
            bool recalc = true;

            void run()
            {   
                Onepole::State s;
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (drive);
                    }

                    loop (updateIntervalSamples)
                    {
                        let y = s.process (in, c);

                        lowpassOut << y[0];
                        highpassOut << y[1];

                        advance();
                    }
                }
            }
        }
    }

    /** soul::tpt::svf modified for cutoff/resonance modulation via input streams
    
        2x oversampling recommended
    */  
    namespace SVF
    {
        struct Coeffs
        {
            SampleType a0;
            SampleType a;
            SampleType p;
        }

        struct State
        {
            SampleType[2] z;
        }

        SampleType[3] process (State& s, SampleType x, const Coeffs& c)
        {
            let hpf = c.a0 * (x - c.p * s.z[0] - s.z[1]);
            let bpf = c.a * hpf + s.z[0];
            let lpf = c.a * bpf + s.z[1];

            s.z[0] = c.a * hpf + bpf;
            s.z[1] = c.a * bpf + lpf;

            return SampleType[3] (lpf, hpf, bpf);
        }

        processor Processor()
        {
            input stream SampleType in;
            input stream SampleType Omega; //angular cutoff; must be > 0
            input stream SampleType R; //resonance; must be > 0
            output stream SampleType lowpassOut, highpassOut, bandpassOut;

            void run()
            {
                State s;
                Coeffs c;

                let Tdiv2 = SampleType (processor.period * 0.5); 

                loop
                {
                    c.a = Omega * Tdiv2; //g
                    c.a0 = SampleType (1.0) / (SampleType (1.0) + SampleType (2.0) * R * c.a + c.a * c.a); //d
                    c.p = SampleType (2.0) * R + c.a; //g1

                    let y = s.process(in, c);

                    lowpassOut  << y[0];
                    highpassOut << y[1];
                    bandpassOut << y[2];
                    
                    advance();
                }
            }
        }
    }
} //namespace VA::Experimental