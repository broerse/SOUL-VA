/** GNU GPLv3 License

    Copyright (C) 2021 ZheDeng
    TheZheDeng@gmail.com

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

/** SOUL-VA (https://github.com/thezhe/SOUL-VA)

    The following interface is nearly identical to soul::filters EXCEPT:
    - Each effect is a 'Processor' under 'VA::HighLevel' (see 'Main Interface')
    - No user defined types:
        *'SampleType' is float64<2>
        *The internal 'CoeffType' is float64<2>
        *Coefficient 'updateInterval' is every 128 samples at 44.1kHz 
        or scaled as needed (i.e. every 256 samples at 88.2kHz)
    - Expanded set of vector-friendly functions (see 'Vectorized Stateless Functions')
    - All effects are optimized for 44.1kHz/24-bit/stereo. 
    Higher sample rates and bit depths degrade performance 
    without guaranteed better quality! Any sampling rate beyond 96000
    is not officially supported.
*/

/** Task List

    Current Tasks:
    - smoothing, update interval 1024 or 128
    - general refactor

    Future Tasks:
    - new stuff towards bottom
    - SOUL doesnt support arrays of input/output events, but refactor if this is changed 
    - rename params with units
    - initialization lists only for Processors and not namespaces
    - SVF/OnepoleS/Compressor Components refactor and use
    - OnepoleS constant c.G value and use soul::dBtoGain for primitives 
*/

namespace VA 
{
/*==============================================================================
VA::HighLevel Processors
==============================================================================*/

    /** High-level Processors made of components from 'VA' and 'soul' namespaces 
    
        All effects can behave nonlinearly and add their own "virtual analog warmth" 
    */
    namespace HighLevel
    {   
        /** A dummy processor that doesn't modify streams
        
            Use case: Debugging
        */
        namespace Dummy
        {
            graph Processor()
            {
                input stream SampleType in;
                output stream SampleType out;
                
                connection
                {
                    in -> out;
                }
            }
        }

        /** 'OnepoleC' in all pass mode modulated by 'LanADAA' 
        
            Use case: Boost and sustain low frequencies
        */
        namespace OnepoleC_Lan
        {
            graph Processor (float initialNonlinearity = 0.f, float initialStereoLink = 0.f)
            {
                input stream SampleType in;
                output stream SampleType out;
        
                input
                {
                    event float nonlinearityIn [[ name: "Nonlinearity", min: 0, max: 275, init: initialNonlinearity, step: 1]];
                    stereoLink.stereoLinkIn;
                    autoSmoothedVolume.parameterIn volumeIn;
                }
        
                let
                {
                    dcBlocker = filt::dc_blocker::Processor (5.f);
                    stereoLink = StereoLink::Processor (initialStereoLink);

                    internal = Internal::Processor (initialNonlinearity) * 2;

                    onepoleMixer = OnepoleMixer::Processor (2);

                    autoSmoothedVolume = AutoSmoothedVolume::Processor(AutoParameter::Modes::OnepoleC_Lan);
                }
        
                connection
                {
                    //event connections
                    nonlinearityIn -> internal.nonlinearityIn;
                    nonlinearityIn -> autoSmoothedVolume.controlIn;

                    //stream connections
                    in -> dcBlocker -> stereoLink.in, internal.in;

                    stereoLink.out -> internal.Lin;

                    internal.highpassOut -> onepoleMixer.highpassIn;
                    internal.lowpassOut -> onepoleMixer.lowpassIn;
                    
                    onepoleMixer.out -> autoSmoothedVolume.in;
                    autoSmoothedVolume.out -> out; 
                }
            }

            namespace Internal 
            {
                graph Processor (float initialNonlinearity = 0.f)
                {
                    input stream SampleType in, Lin;
                    output stream SampleType highpassOut, lowpassOut;
            
                    input
                    {
                        L.nonlinearityIn;
                    }

                    let
                    {
                        L = LanADAA::Processor (initialNonlinearity);
                        onepoleC = OnepoleC::Processor;
                    }
            
                    connection
                    {
                        in -> onepoleC.in;

                        Lin -> L.in;
                        L.Omega -> onepoleC.Omega;

                        onepoleC.highpassOut -> highpassOut;
                        onepoleC.lowpassOut -> lowpassOut;
                    }
                }
            }    
        }
        
        /** Modulated 'DelayLine' with 'LadderFilterS' in the feedback loop 
        
            Notes:
            - Loosely based on Boss CE2 Chorus Pedal
            - Use case: Chorus, slow flange, doubler
        */
        namespace Chorus_LadderLPFS
        {
            graph Processor(float initialDelayMs = 3,
                            float initialRateHz = 1,
                            float initialDepth = 50,
                            float initialCutoff = 9000,
                            float initialResonance = 0.f,
                            float initialMix = 50,
                            float initialPan = 0)
            {
                input stream SampleType in;
                output stream SampleType out;
        
                input
                { 
                    delayLine.delayIn [[ name: "Delay", min: 0, max: 20, init: initialDelayMs, unit: "ms", step: 1 ]];

                    lfo.rateHzIn [[ name: "Rate (Hz)", min: 0.01, max: 2.0, init: initialRateHz, unit: "Hz", step: 0.01 ]];
                    lfo.depthIn [[ name: "Depth", min: 0, max: 100, init: initialDepth, unit: "%", step: 1 ]];
                    
                    ladderLPFS.cutoffIn [[ name: "Cutoff", min: 60, max: 16000, init: initialCutoff, unit: "Hz", step: 1 ]];
                    ladderLPFS.resonanceIn [[ name: "Resonance", min: 0, max: 1, init: initialResonance, step: 0.01f ]];
                    ladderLPFS.nlModeIn;

                    smoothedMixPan.mixIn;
                    smoothedMixPan.panIn;
                }
        
                let
                {
                    dcBlocker = filt::dc_blocker::Processor (20.f);

                    lfo = osc::lfo::Processor;
                    ladderLPFS = LadderLPFS::Processor (initialCutoff, initialResonance, 0, 4);

                    delayLine = DelayLine::Processor (initialDelayMs);
                    
                    smoothedMixPan = SmoothedMixPan::Processor (initialMix, initialPan, SLEW_RATE_SECONDS_GAIN);
                }
        
                connection
                {
                    lfo.out -> delayLine.lfoIn;
                    
                    in -> dcBlocker -> delayLine.in, smoothedMixPan.in0;
                    
                    delayLine.out -> ladderLPFS.in;
                    ladderLPFS.out -> smoothedMixPan.in1;
                    
                    smoothedMixPan.out -> out;
                }
            }
        }
    } //namespace HighLevel

/*==============================================================================
Filter Processors
==============================================================================*/

    /** Ladder Low Pass Filter with variable order and saturating state 
    
        Notes:
        - Resonance up to order/2 reccomended
        - Even though its nonlinear, the filter can become unstable because the state sat function is not bounded
    */
    namespace LadderLPFS
    {   
        struct Coeffs
        {
            SampleType g; //G for onepole stages
            SampleType k; //resonance
            int nlMode;
        }
    
        void update (Coeffs& c, float cutoff, float resonance, float nlMode, SampleType Tpi)
        {
            let gOnepole = tanh (SampleType (cutoff) * Tpi);

            c.g = gOnepole / (ONE + gOnepole);
            c.k = SampleType (resonance);
            c.nlMode = int (nlMode);
        }
    
        namespace M (int order)
        {
            static_assert (order % 2 == 0, "LadderFilter: order must be even.");

            struct State
            {
                SampleType[order] s;
            }

            SampleType process (State& s, SampleType x, const Coeffs& c)
            {
                var S = ZERO;
                var G = ONE;
                for (int i = order - 1; i > -1; --i)
                {
                    S += G * s.s.at(i);
                    G *= c.g;
                }

                //input to first lowpass ('u')
                var y = (x - c.k * S) / (ONE + c.k * G);

                //'order' lowpasses in series 
                for (int i = 0; i < order; ++i)
                {
                    let v = (y - s.s.at(i)) * c.g;
                    y = v  + s.s.at(i);
                    let sLin = v + y;

                    if (c.nlMode == 0)
                        s.s.at(i) =  sLin;
                    else if (c.nlMode == 1)
                        s.s.at(i) =  vBBD (sLin);
                    else if (c.nlMode == 2)
                        s.s.at(i) =  vsigmoidCD (sLin);
                }
                
                return y * (ONE + c.k); //normalize
            }
        }
    
        processor Processor (float initialCutoff = 1000, float initialResonance = 1, float initialNlMode = 0, int order = 4)
        {
            input stream SampleType in;
            output stream SampleType out;

            input event float cutoffIn [[ name: "Cutoff", min: MIN_CUTOFF_HZ, max: MAX_CUTOFF_HZ, init: initialCutoff, unit: "Hz", step: 1 ]];
            input event float resonanceIn [[ name: "Resonance", min: 0, max: order, init: initialResonance, step: 0.01f ]];
            input event float nlModeIn [[ name: "Nonlinearity", min: 0, max: 2, init: initialNlMode, text: "None|BBD|Tanh", step: 1 ]];
            
            event cutoffIn (float v) { cutoff = v; recalc = true; }
            event resonanceIn (float v) { resonance = v; recalc = true; }
            event nlModeIn (float v) { nlMode = v; recalc = true; }

            float cutoff = initialCutoff;
            float resonance = initialResonance;
            float nlMode = initialNlMode;
            bool recalc = true;
    
            void run()
            {   
                M(order)::State s;
                Coeffs c;
    
                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                let Tpi = SampleType (processor.period * pi);
    
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (cutoff, resonance, nlMode, Tpi);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << M (order)::process (s, in, c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** OnepoleC with differing cutoff depending on rising/falling output relative to stored output (feedback)*/
    namespace BallisticsFilter_Lan
    {
        namespace BranchingCutoff_Lan
        {
            struct Coeffs 
            {
                Lan::Coeffs attack;
                Lan::Coeffs release;
            }

            void update (Coeffs& c, float attack, float attackNonlinearity, float release, float releaseNonlinearity) 
            {
                Lan::update (c.attack, attackNonlinearity, attack);
                Lan::update (c.release, releaseNonlinearity, release);
            }

            SampleType process (SampleType x, SampleType y, const Coeffs& c) 
            {
                return vifgt (Lan::process (x, c.attack), Lan::process(x, c.release), x, y);  
            }

            processor Processor(float initialAttackNonlinearity,
                                float initialAttack,
                                float initialReleaseNonlinearity,
                                float initialRelease)
            {
                input stream SampleType x, y;
                output stream SampleType Omega;
        
                input event
                { 
                    float attackIn [[ name: "Attack", min: 1, max: 200, init: initialAttack, unit: "ms", step: 1 ]];
                    float attackNonlinearityIn [[ name: "Attack Nonlinearity", min: 0, max: 1000, init: initialAttackNonlinearity, step: 1 ]];
                    float releaseIn [[ name: "Release", min: 1, max: 500, init: initialRelease, unit: "ms", step: 1 ]];
                    float releaseNonlinearityIn [[ name: "Release Nonlinearity", min: 0, max: 1000, init: initialReleaseNonlinearity, step: 1]];
                }

                event attackIn (float v) { attack = v; recalc = true; }
                event attackNonlinearityIn (float v) { attackNonlinearity = v; recalc = true; }
                event releaseIn (float v) { release = v; recalc = true; }
                event releaseNonlinearityIn (float v) { releaseNonlinearity = v; recalc = true; }

                float attack = initialAttack;
                float attackNonlinearity = initialAttackNonlinearity;
                float release = initialRelease;
                float releaseNonlinearity = initialReleaseNonlinearity;
                bool recalc = true;
        
                void run()
                {
                    Coeffs c;

                    let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
        
                    loop
                    {
                        if (recalc)
                        {
                            recalc = false;
        
                            c.update (attack, attackNonlinearity, release, releaseNonlinearity);
                        }
        
                        loop (updateIntervalSamples)
                        {
                            Omega << process(x, y, c);
        
                            advance();
                        }
                    }
                }
            }
        }

        graph Processor (float initialAttackNonlinearity,
                        float initialAttack,
                        float initialReleaseNonlinearity,
                        float initialRelease)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                branchingCutoff.attackIn;
                branchingCutoff.attackNonlinearityIn;
                branchingCutoff.releaseIn;
                branchingCutoff.releaseNonlinearityIn;
            }
    
            let
            {
                branchingCutoff = BranchingCutoff_Lan::Processor (initialAttack, initialAttackNonlinearity, initialRelease, initialReleaseNonlinearity);
                onepoleC = OnepoleC::Processor;
            }
    
            connection
            {
                in -> onepoleC.in;

                onepoleC.lowpassOut -> [1] -> branchingCutoff.x;
                onepoleC.lowpassOut -> [2] -> branchingCutoff.y;
                branchingCutoff.Omega -> onepoleC.Omega;

                onepoleC.lowpassOut -> out;
            }
        }
    }

    /** Onepole modified for cutoff modulation via an input stream
        
        - 2x oversampling reccomended if using as a frequency effect
    */
    namespace OnepoleC
    {   
        processor Processor
        {
            input stream SampleType in;
            input stream SampleType Omega;
            output stream SampleType lowpassOut, highpassOut;

            void run()
            {   
                Onepole::State s;
                Onepole::Coeffs c;

                let Tdiv2 = SampleType (processor.period * 0.5);

                loop
                {
                    let temp = Omega * Tdiv2; 
                    c.G = temp / (ONE + temp);

                    let y = Onepole::process (s, in, c);

                    lowpassOut << y[0];
                    highpassOut << y[1];

                    advance();
                }
            }
        }
    }

    /** Mix outputs from Onepole to make more complicated frequency responses */
    namespace OnepoleMixer
    {   
        struct Coeffs
        {
            int m;
        }
    
        void update (Coeffs& c, float mode)
        {
            c.m = int (mode);
        }
    
        SampleType process (SampleType hpf, SampleType lpf, const Coeffs& c)
        {
            if (c.m == 0)
                return hpf;
            else if (c.m == 1)
                return lpf;
            else
                return lpf - hpf;
        }
    
        processor Processor (int initialMode = 0)
        {
            input stream SampleType lowpassIn, highpassIn;
            output stream SampleType out;
    
            input event float modeIn [[ name: "Mode", min: 0, max: 2, init: initialMode, text: "HPF|LPF|APF" ]];

            static_assert ((initialMode >= 0 && initialMode <= 2), "initialMode must be in range [0, 2]");
    
            event modeIn (float v) { mode = v; recalc = true; }
    
            float mode = float (initialMode);
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (mode);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (highpassIn, lowpassIn, c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** SOUL-VA's version of soul::filters::tpt::onepole  

        Notes:
        - If sampling rate is 44.1kHz, use 2x oversampling
        - Structure is more consistent with SVF and oversampling is used instead of prewarping
    */
    namespace Onepole
    {   
        struct Coeffs
        {
            SampleType G;
        }

        struct State
        {
            SampleType s;
        }

        void update (Coeffs& c, float frequency, SampleType Tpi)
        {
            let g = Tpi * SampleType (frequency);
            c.G = g / (ONE + g);
        }

        SampleType[2] process (State& s, SampleType x, const Coeffs& c)
        {
            let v = (x - s.s) * c.G;
            let lpf = v + s.s;
            let hpf = x - lpf;

            s.s = v + lpf;

            return SampleType[2] (lpf, hpf);
        }

        processor Processor (float initialFrequency)
        {
            input stream SampleType in;
            output stream SampleType lowpassOut, highpassOut;

            input event float frequencyIn [[ name: "Frequency", min: 20, max: 20000, init: initialFrequency, text: "Hz" ]];

            event frequencyIn (float v) { frequency = v; recalc = true; }

            float frequency = float (initialFrequency);
            bool recalc = true;

            void run()
            {   
                State s;
                Coeffs c;

                let Tpi = SampleType (processor.period * pi);
                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (frequency, Tpi);
                    }

                    loop (updateIntervalSamples)
                    {
                        let y = s.process (in, c);

                        lowpassOut << y[0];
                        highpassOut << y[1];

                        advance();
                    }
                }
            }
        }
    }

    /** Modified version of https://soul.dev/lab/?id=Delay 
    
        Notes:
        - max 500 ms delay with ability to modulate +- 5ms
        - for feedback make a loop with a unit delay (i.e. DelayLine.out -> [1] -> add your effects here -> DelayLine.in)
    */
    namespace DelayLine
    {   
        struct State 
        {
            wrap<MAX_BUFFER_SIZE> readPos, writePos;
            SampleType[MAX_BUFFER_SIZE] buffer;
        }

        void update (State& s, float delayMs, float fsDiv1k)
        {
            s.readPos = wrap<MAX_BUFFER_SIZE> (s.writePos - int (fsDiv1k * delayMs));
        }

        SampleType process (State& s, SampleType x, float lfo, float maxDepthSamples)
        {
            s.buffer.at (s.writePos) = x;

            let y = s.buffer.readLinearInterpolated (float(s.readPos) - maxDepthSamples * lfo);

            ++s.readPos;
            ++s.writePos;

            return y;
        }

        processor Processor (float initialDelayMs = 50, float maxDepthMs = 2)
        {
            input stream SampleType in;
            input stream float lfoIn; //max amplitude should be <= 1
            output stream SampleType out;

            input event float delayIn [[ name: "Delay", min: 0, max: 500, init: initialDelayMs, unit: "ms", step: 1 ]];

            event delayIn (float v) { delayMs = v; recalc = true; }

            float delayMs = initialDelayMs;
            bool recalc = true;
    
            void run()
            {  
                State s;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                let fsDiv1k = float (processor.frequency) / 1000.f;
                let maxDepthSamples = maxDepthMs * fsDiv1k;

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        s.update (delayMs, fsDiv1k);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << s.process (in, lfoIn, maxDepthSamples);

                        advance();
                    }
                }
            }
        }
    }
    
/*==============================================================================
Mix Processors
==============================================================================*/
    
    /** Smoothed Volume with an automatic volume curve option */
    namespace AutoSmoothedVolume
    {
        graph Processor(int mode = AutoParameter::Modes::None)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                autoParameter.controlIn;
                autoParameter.parameterIn;
            }
    
            let
            {
                autoParameter = AutoParameter::Processor (mode);
                smoothedGain_Volume = SmoothedGain::Processor (AutoParameter::M(mode)::InitialParameter, SmoothedGain::Modes::Decibel);
            }
    
            connection
            {
                in -> smoothedGain_Volume.in;

                autoParameter.parameterOut -> smoothedGain_Volume.valueIn;

                smoothedGain_Volume.out -> out;
            }
        }
    }

    /** Apply mixing and panning via VA::SmoothedParameter */
    namespace SmoothedMixPan
    {
        graph Processor(float initialMix = 50, float initialPan = 0, float slewRateSeconds = SLEW_RATE_SECONDS_GAIN)
        {
            input stream SampleType in0, in1;
            output stream SampleType out;
    
            input
            {
                smoothedGains.in0 mixIn [[ name: "Mix", min: 0, max: 100, init: initialMix, unit: "%", step: 1 ]];
                smoothedGains.in1 panIn [[ name: "Pan", min: -1, max: 1, init: initialPan, step: 0.01f ]];
            }

            let
            {
                applyGains = ApplyGains::Processor;
                smoothedGains = SmoothedParameter::Processor(float[2] (initialMix, initialPan), SmoothedParameter::Modes::MixPan, slewRateSeconds);
            }
    
            connection
            {
                smoothedGains.out0 -> applyGains.b0;
                smoothedGains.out1 -> applyGains.b1;

                in0 -> applyGains.in0;
                in1 -> applyGains.in1;

                applyGains.out -> out;
            }
        }
    }
    
    /** Apply a gain via VA::SmoothedParameter */
    namespace SmoothedGain
    {
        namespace Modes
        {
            let Linear = 0;
            let Decibel = 1;
        }

        namespace M (int mode = 0)
        {
            let Min = (mode == Modes::Linear ? 0 : (mode == Modes::Decibel ? -12 : 0));
            let Max = (mode == Modes::Linear ? 1 : (mode == Modes::Decibel ? 0 : 100));
            let Step = (mode == Modes::Linear ? 0.01f : (mode == Modes::Decibel ? 0.1f : 1.f));
        }

        graph Processor (float initialValue = 0, int mode = 0, float slewRateSeconds = 0.1f)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event float valueIn [[ name: (mode == Modes::Linear ? "Gain" : (mode == Modes::Decibel ? "Volume" : "Depth")), min: M(mode)::Min, max: M(mode)::Max, init: initialValue, step: M(mode)::Step, unit: (mode == Modes::Linear ? "" : (mode == Modes::Decibel ? "dB" : "%")) ]];
    
            let
            {
                smoothedGain = SmoothedParameter::Processor (float[2] (initialValue, 0), mode, slewRateSeconds);
                multiplier = Multiplier::Processor;
            }
    
            connection
            {
                in -> multiplier.in;
                
                valueIn -> smoothedGain.in0;
                smoothedGain.out0 -> multiplier.b;

                multiplier.out -> out;
            }
        }
    }

/*==============================================================================
Parameter Processors
==============================================================================*/

    /** Automatic/manual parameter for VA::HighLevel Processors 

        Use case: currently only for auto gain compensation
    */
    namespace AutoParameter
    {   
        struct State
        {
            float prevVol;
            float prevParam;
        }

        namespace Modes
        {
            let None = 0;
            let OnepoleC_Lan = 1;
            let NumModes = 2;
        }

        namespace M (int mode = Modes::None)
        {
            static_assert ((mode < Modes::NumModes) && (mode > -1), "AutoParameter: mode out of range.");

            let MaxParameter = (mode == Modes::None ? 12.f : 0.f);
            let MinParameter = (mode == Modes::None ? -12.f : -6.1f);
            let InitialParameter = (mode == Modes::None ? 0.f : MinParameter);
            let MinManualParameter = (mode == Modes::None ? -inf : MinParameter + 0.1f);
            let PtsSize = (mode == Modes::None ? 1 : 4);
            let Pts = (mode == Modes::None ? float[PtsSize] (0) : float[PtsSize] (-0.f, -1.f, -2.f, -3.5f));

            float process (float x, float[] pts)
            {
                if const (mode == Modes::None)
                    return x;
                else if const (mode == Modes::OnepoleC_Lan)
                    return pts.readLinearInterpolated (min (x * 0.1f, 3.f));
            }
        }

        processor Processor (int mode = Modes::None)
        {
            input event float controlIn; //auto mode only
            output event float parameterOut;

            input event float parameterIn [[name: "Volume", min: M(mode)::MinParameter, max: M(mode)::MaxParameter, init: M(mode)::InitialParameter, step: 0.1, unit: "dB"]];
            
            let pts = M(mode)::Pts;
            State s;

            float process (float x)
            {
                return M(mode)::process (x, pts);
            }

            event controlIn (float v) 
            { 
                s.prevParam = v;

                if (s.prevVol < M(mode)::MinManualParameter)
                    parameterOut << process (s.prevParam); 
            }

            event parameterIn (float v)
            {
                s.prevVol = v;
                
                if (v < M(mode)::MinManualParameter)
                    parameterOut << process (s.prevParam);
                else
                    parameterOut << v;
            }

            void run() 
            { 
                advance();
            }
        }
    }

    /** Map input events to a smoothed output stream; Modified version of soul::gain::SmoothedGainParameter

        Note: 'slewRateSeconds' is NOT the same as in soul::gain::SmoothedGain Parameter; it is the max change in linear gain per second
        (e.g., if slewRateSeconds 0.5 and gain changes by 1, then it will take 2 seconds to reach a gain of 1)  
    */    
    namespace SmoothedParameter
    {
        namespace Modes
        {
            let Linear = 0;
            let Decibel = 1;
            let MixPan = 2;
        }

        namespace M (int mode = Modes::Linear)
        {
            let NumIn = (mode == Modes::MixPan ? 2 : 1);
            let NumOut = (mode == Modes::MixPan ? 2 : 1);
            
            struct Coeffs
            {
                SampleType[NumOut] target;
                SampleType[NumOut] increment;
            }

            struct State
            {
                SampleType[NumOut] current;
                int remainingRampSamples;
            }

            void update (Coeffs& c, float[] parameter, State& s, SampleType divMaxDelta)
            {
                if const (mode == Modes::Linear)
                    c.target.at(0) = SampleType (parameter.at(0));
                else if const (mode == Modes::Decibel)
                    c.target.at(0) = vdBtoGain (SampleType (parameter.at(0)));
                else if const (mode == Modes::MixPan)
                    c.target = vmixPanToGains (parameter.at(0), parameter.at(1));

                if const (mode == Modes::Linear || mode == Modes::Decibel)
                    s.remainingRampSamples = int (vclamp (1, INF32)::process (vabs (c.target.at(0) - s.current.at(0)) * divMaxDelta) [0]);
                else if const (mode == Modes::MixPan)
                    s.remainingRampSamples = int (vmaxR (vclamp (1, INF32)::process (vabs (c.target.at(0) - s.current.at(0)) * divMaxDelta)));

                for (int i = 0; i < c.increment.size; ++i)
                    c.increment.at(i) = (c.target.at(i) - s.current.at(i)) / SampleType (s.remainingRampSamples);
            }

            void updateUnsmoothed (Coeffs& c, float[] parameter, State& s)
            {
                if const (mode == Modes::Linear)
                    s.current.at(0) = SampleType (parameter.at(0));
                else if const (mode == Modes::Decibel)
                    s.current.at(0) = vdBtoGain (SampleType (parameter.at(0)));
                else if const (mode == Modes::MixPan)
                    s.current = vmixPanToGains (parameter.at(0), parameter.at(1));

                s.remainingRampSamples = 0;
            }

            SampleType[NumOut] process (State& s, const Coeffs& c)
            {
                if (s.remainingRampSamples != 0)
                {
                    if (--(s.remainingRampSamples) == 0)
                    {
                        for (int i = 0; i < s.current.size; ++i)
                            s.current.at(i) = c.target.at(i);
                    }
                    else
                    {
                        for (int i = 0; i < s.current.size; ++i)
                            s.current.at(i) += c.increment.at(i);
                    }
                }

                return s.current;
            }
        }

        processor Processor (float[] initialParameter, int mode = 0, float slewRateSeconds = SLEW_RATE_SECONDS_GAIN)
        {
            output stream SampleType out0, out1;

            input event float in0, in1;

            event in0 (float v) { parameter.at(0) = v; recalc = true; }
            event in1 (float v) { parameter.at(1) = v; recalc = true; }

            float[M(mode)::NumIn] parameter = initialParameter;
            bool recalc = false;

            void run()
            {   
                M(mode)::State s;
                M(mode)::Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
                let divMaxDelta = SampleType (float (processor.frequency) / slewRateSeconds);
    
                M(mode)::updateUnsmoothed (c, parameter, s);
            
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        M(mode)::update (c, parameter, s, divMaxDelta);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        let y = M(mode)::process (s, c);

                        out0 << y.at(0);

                        if const (M(mode)::NumOut > 1)
                            out1 << y.at(1);

                        advance();
                    }
                }
            }
        }
    }

/*==============================================================================
Vectorized Stateless Function Wrapper Processors
==============================================================================*/

    /** A standard CTF (compressor transfer function)

        See: https://www.dropbox.com/s/cjq4t08u6pqkaas/ADC17FiftyShadesDistortion.zip?dl=0&file_subpath=%2FCode%2FDynamicsCompressor.cpp
    */
    namespace CTF
    {
        struct Coeffs 
        {
            SampleType threshold;
            SampleType ratio1;
            SampleType ratio2;
        }
    
        void update (Coeffs& c, float threshold, float ratio1, float ratio2) 
        {
            c.threshold = SampleType (threshold);
            c.ratio1 = SampleType (ratio1);
            c.ratio2 = SampleType (ratio2);
        }
    
        SampleType process (SampleType x, const Coeffs& c) 
        {
            return vCTF (x, c.threshold, c.ratio1, c.ratio2);
        }

        processor Processor(float initialThreshold = -20.f, float initialRatio1 = 2.f, float initialRatio2 = 2.f)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event float thresholdIn [[ name: "Threshold", min: -60.f, max: 0.f, init: initialThreshold, unit: "dB" ]];
            input event float ratio1In [[ name: "Ratio 1", min: 0.5f, max: 50.f, init: initialRatio1 ]];
            input event float ratio2In [[ name: "Ratio 2", min: 0.5f, max: 50.f, init: initialRatio2 ]];

            event thresholdIn (float v) { threshold = v; recalc = true; }
            event ratio1In (float v) { ratio1 = v; recalc = true; }
            event ratio2In (float v) { ratio2 = v; recalc = true; }

            float threshold = initialThreshold;
            float ratio1 = initialRatio1;
            float ratio2 = initialRatio2;
            bool recalc = true;

            void run()
            {
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
            
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (threshold, ratio1, ratio2);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (in, c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** A compressor transfer function (CTF) with color
        
        Notes:
        - Algebraic bell-shaped function (derivative of a sigmoidal function arctan) used for color
        - See https://ocw.mit.edu/courses/mathematics/18-01sc-single-variable-calculus-fall-2010/1.-differentiation/part-falseStatement-implicit-differentiation-and-inverse-functions/session-15-implicit-differentiation-and-inverse-functions/MIT18_01SCF10_Ses15b.pdf
        - See https://blog.audio-tk.com/2015/09/08/audio-toolkit-additional-gain-functions/
    */
    namespace CTF_Color
    {
        struct Coeffs 
        {
            SampleType threshold;
            SampleType ratio;
            SampleType height;
            SampleType width; 
        }
    
        void update (Coeffs& c, float threshold, float ratio, float colorHeight, float colorWidth) 
        {
            c.threshold = SampleType (threshold);
            c.ratio = SampleType (ratio);
            c.height = SampleType (colorHeight);
            c.width = SampleType (colorWidth);
        }
    
        SampleType process (SampleType x, const Coeffs& c) 
        {
            return vCTF_Color (x, c.threshold, c.ratio, c.height, c.width);
        }

        processor Processor(float initialThreshold = -20,
                            float initialRatio = 5,
                            float initialHeight = 5,
                            float initialWidth = 3)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event float thresholdIn [[ name: "Threshold", min: -60.f, max: 0.f, init: initialThreshold, unit: "dB" ]];
            input event float ratioIn [[ name: "Ratio", min: 1.f, max: 100.f, init: initialRatio ]];
            input event float heightIn [[ name: "Height", min: -12.f, max: 12.f, init: initialHeight, unit: "dB" ]];
            input event float widthIn [[ name: "Width", min: -12.f, max: 12.f, init: initialWidth, unit: "dB" ]];

            event thresholdIn (float v) { threshold = v; recalc = true; }
            event ratioIn (float v) { ratio = v; recalc = true; }
            event colorHeightIn (float v) { height = v; recalc = true; }
            event colorWidthIn (float v) { width = v; recalc = true; }

            float threshold = initialThreshold;
            float ratio = initialRatio;
            float height = initialHeight;
            float width = initialWidth;
            bool recalc = true;

            void run()
            {
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
            
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (threshold, ratio, height, width);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (in, c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** Average a SampleType stream with a copy that has swapped channels */
    namespace StereoLink
    {   
        struct Coeffs
        {
            SampleType[2] b;
            float stereoLink;
        }
    
        void update (Coeffs& c, float stereoLink)
        {
            c.b = vmixToGains (stereoLink * 0.5f);
            c.stereoLink = stereoLink;
        }
    
        SampleType process (SampleType x, const Coeffs& c)
        {
            if (c.stereoLink == 0.f)
                return x;
            else if (c.stereoLink == 100.f)
                return SampleType (x.sum()/x.size);
            else
            {
                let x1 = SampleType (x[1] , x[0]);

                return c.b.at(0) * x + c.b.at(1) * x1;
            }
        }
    
        processor Processor (float initialStereoLink = 0)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event float stereoLinkIn [[ name: "Stereo Link", min: 0, max: 100, init: initialStereoLink, unit: "%" ]];
            
            event stereoLinkIn (float v) { stereoLink = v; recalc = true; }

            float stereoLink = initialStereoLink;
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;
    
                let updateIntervalSamples = int ((processor.frequency/44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (stereoLink);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (in, c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** 'vLan' with ADAA and a linear angular cutoff of 2pi
    
        Notes:
        - optimized for use with OnepoleC or modulating frequency domain filters
        - If sampling rate is 44.1kHz, use 2x oversampling
    */
    namespace LanADAA
    {   
        struct Coeffs
        {
            SampleType N;
        }
    
        void update (Coeffs& c, float nonlinearity)
        {
            c.N = SampleType (nonlinearity);
        }    
    
        SampleType f (SampleType x, const Coeffs& c)
        {
            return vLan (x, c.N);
        }
    
        SampleType F1 (SampleType x, const Coeffs& c)
        {
            return vpowi (x, 3) * vpowi (c.N, 2) * SampleType (1.0 / 3.0) + c.N * vpowi (x, 2) * vsgn (x) + x;
        }
    
        SampleType F2 (SampleType x, const Coeffs& c)
        {
            return vpowi (x, 2) * (HALF + c.N * SampleType (1.0 / 3.0) * x * vsgn (x) + vpowi (c.N, 2) * SampleType (1.0 / 12.0) * vpowi (x, 2));
        }
    
        struct State
        {
            SampleType x_2;
            SampleType x_1;
            SampleType F2_1;
            SampleType F1_1;
        }
    
        void reset (State& s)
        {
            s.x_2 = ZERO;
            s.x_1 = ZERO;
            s.F2_1 = ZERO;
            s.F1_1 = ZERO;
        }

        SampleType processADAA2 (State& s, SampleType x, const Coeffs& c)
        {
            //Find F1_0
            
            let x_0mx_1 = x - s.x_1;
            let F2_0 = F2 (x, c);
    
            let F1_0 = viflt (F1 (HALF * (x + s.x_1), c), 
                (F2_0 - s.F2_1) / x_0mx_1,
                vabs (x_0mx_1), ADAA_TOL);
    
            //Find f_0
            let x_0mx_2 = x - s.x_2;
    
            let xBar = HALF * (x + s.x_2);
            let delta = xBar - x;
    
            let f_0 = viflt (
                viflt (
                    f (HALF * (xBar + x), c),
                    (TWO / delta) * (F1 (xBar, c) + (F2_0 - F2 (xBar, c)) / delta),
                    vabs (delta), ADAA_TOL
                ),
                (TWO / (x_0mx_2)) * (F1_0 - s.F1_1),
                vabs (x_0mx_2), ADAA_TOL
            );
    
            //update s
            s.x_2 = s.x_1;
            s.x_1 = x;
            s.F2_1 = F2_0;
            s.F1_1 = F1_0;
    
            return f_0;
        }
    
        SampleType process (State& s, SampleType x, const Coeffs& c)
        {
            return s.processADAA2 (x, c);
        }
    
        processor Processor (float initialNonlinearity = 0.f)
        {
            input stream SampleType in;
            output stream SampleType Omega;

            input event float nonlinearityIn [[ name: "Nonlinearity", min: 0, max: 275, init: initialNonlinearity, step: 1]];

            event nonlinearityIn (float v) { nonlinearity = v; recalc = true; }
            
            float nonlinearity = initialNonlinearity;
            bool recalc = true;

            void run()
            {
                State s;
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (nonlinearity);
                        s.reset();
                    }

                    loop (updateIntervalSamples)
                    {
                        Omega << (SampleType (twoPi - 1) + s.process (in, c));

                        advance();
                    }
                }
            }
        }
    }

    /** 'vLan' Processor wrapper
    
        Notes:
        - optimized for use with step-reponse filters
    */
    namespace Lan
    {   
        struct Coeffs
        {
            SampleType N;
            SampleType bias;
        }
    
        void update (Coeffs& c, float nonlinearity, float tau)
        {
            c.N = SampleType (nonlinearity);
            c.bias = SampleType (1000.0) / SampleType (tau) - ONE;
        }    

        SampleType process (SampleType x, const Coeffs& c)
        {
            return c.bias + vLan (x, c.N);
        }
    
        processor Processor (float initialNonlinearity = 0.f, float initialTau = 20.f)
        {
            input stream SampleType in;
            output stream SampleType Omega;

            input event float nonlinearityIn [[ name: "Nonlinearity", min: 0, max: 275, init: initialNonlinearity, step: 1 ]];
            input event float tauIn [[ name: "Tau", min: 0, max: 500, init: initialTau, step: 1 ]];

            event nonlinearityIn (float v) { nonlinearity = v; recalc = true; }
            event tauIn (float v) { tau = v; recalc = true; }

            float tau = initialTau;
            float nonlinearity = initialNonlinearity;
            bool recalc = true;

            void run()
            {
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (nonlinearity, tau);
                    }

                    loop (updateIntervalSamples)
                    {
                        Omega << process (in, c);

                        advance();
                    }
                }
            }
        }
    }

    namespace Abs
    {
        processor Processor()
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << vabs (in);

                    advance();
                }
            }
        }
    }

    namespace Multiplier
    {
        processor Processor
        {
            input stream SampleType b;
            input stream SampleType in;
            output stream SampleType out;
    
            void run()
            {
                loop
                {
                    out << b * in;
    
                    advance();
                }
            }
        }
    }

    namespace ApplyGains
    {
        processor Processor
        {
            input stream SampleType b0, b1;
            input stream SampleType in0, in1;
            output stream SampleType out;
    
            void run()
            {
                loop
                {
                    out << b0 * in0 + b1 * in1;
    
                    advance();
                }
            }
        }
    }

    namespace Adder
    {
        processor Processor
        {
            input stream SampleType in1, in2;
            output stream SampleType out;
    
            void run()
            {
                loop
                {
                    out << in1 + in2;
    
                    advance();
                }
            }
        }
    }

/*==============================================================================
Vectorized Stateless Functions
==============================================================================*/

    /** BBD mapping from http://dafx10.iem.at/proceedings/papers/RaffelSmith_DAFx10_P42.pdf 
    
        Use for low order, monotonically decreasing harmonics
    */
    SampleType vBBD (SampleType x)
    {
        let a = SampleType (1.0/8.0);
        let b = SampleType (1.0/16.0);

        return x - a * vpowi (x, 2) - b * vpowi (x, 3); 
    }

    SampleType vCTF_Color (SampleType x, SampleType thr, SampleType ratio, SampleType height, SampleType width)
    {
        let xdB = vgainTodB(x);
        let xdBmthr = xdB - thr;

        let color = height / (ONE + vpowi (xdBmthr * ONE/width, 2));
        let ydB = vifgt (thr + xdBmthr * ONE/ratio + color, xdB + color, xdB, thr);

        return vdBtoGain(ydB) / x;
    }

    SampleType vCTF (SampleType x, SampleType threshold, SampleType ratio1, SampleType ratio2)
    {
        let divRatio1m1 = ONE/ratio1 - ONE;
        let divRatio2m1 = ONE/ratio2 - ONE;
        let thrlin = vdBtoGain (threshold);

        let y = vifgt (vpow (x * (ONE/thrlin), divRatio1m1), vpow (x * (ONE/thrlin), divRatio2m1), x, thrlin);
        return vifgt (y, ONE, x, SampleType(0.001));
    }

    /** Cutoff (Omega) modulation from an anhysteretic first-order nonlinear inductor circuit
    
        The linear cutoff is 1. Add a bias if a different linear cutoff is desired
        ie:
        vLan(x, N) + bias
    */
    SampleType vLan (SampleType x, SampleType N)
    {
        return vpowi (N * vabs (x) + ONE, 2);
    }

    /** 'pow' for small integer exponents */
    SampleType vpowi (SampleType base, int exponent)
    {
        SampleType y = base;

        for (int i = 1; i < exponent; ++i)
            y *= base;

        return y;
    }

    /** 'pow' for SOUL vectors*/
    SampleType vpow (SampleType base, SampleType exponent)
    {
        return SampleType (pow (base[0], exponent[0]), pow (base[1], exponent[1]));
    }

    /** vectorized version of 
    
        return (a < b ? trueStatement : falseStatement);   
    */
    SampleType viflt (SampleType trueStatement, SampleType falseStatement, SampleType a, SampleType b)
    {
        return SampleType (a[0] < b[0] ? trueStatement [0] : falseStatement [0], a[1] < b[1] ? trueStatement [1] : falseStatement [1]);
    }
    
    /** vectorized version of 
        
        return (a > b ? trueStatement : falseStatement);   
    */
    SampleType vifgt (SampleType trueStatement, SampleType falseStatement, SampleType a, SampleType b)
    {
        return SampleType (a[0] > b[0] ? trueStatement [0] : falseStatement [0], a[1] > b[1] ? trueStatement [1] : falseStatement [1]);
    }

    /** clamp a value between low and high

        If 'low' = INF32 or 'high' = INF32, they will be optimized out at compile time
    */
    namespace vclamp (float low = float (-inf), float high = float (inf))
    {       

        let l = SampleType.primitiveType (low);
        let h = SampleType.primitiveType (high);

        SampleType process (SampleType x)
        {
            if const (low > -INF32 && high < INF32)
                return SampleType (clamp (x[0], l, h), clamp (x[1], l, h)); 
            else if const (low > -INF32)
                return SampleType (max (x[0], l), max (x[1], l));
            else
                return SampleType (min (x[0], h), min (x[1], h));
        }

        processor Processor ()
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << process (in);

                    advance();
                }
            }
        }
    }

    /** Convert a mix and a pan to a SampleType[2] gain array
    
        Use case: mix and pan 2 SampleType streams simultaneously
    */
    SampleType[2] vmixPanToGains (float m, float p)
    {
        let bPan = vpanToGains (p);
        let bMix = vmixToGains (m);

        return SampleType[2] (bMix.at(0) * bPan.at(0), bMix.at(1) * bPan.at(1));
    }

    /** Convert a mix value in range [0, 100] to a SampleType[2] gain array
    
        Use case: mix 2 SampleType streams
    */
    SampleType[2] vmixToGains (float x)
    {
        let b1 = SampleType (x) * SampleType (1.0/100.0);

        return SampleType[2] (ONE - b1, b1);
    }
    
    /** Convert a pan value in range [-1, 1] to a SampleType[2] gain array
    
        Use case: pan 2 SampleType streams simultaneously
    */
    SampleType[2] vpanToGains (float x)
    {
        let b1 = vpanToGain(x);

        return SampleType[2] (ONE - b1, b1);
    }

    /** Convert a linear pan value in range [-1, 1] to a SampleType gain 

        Use case: pan 1 SampleType stream
    */
    SampleType vpanToGain (float x)
    {
        let bR = (float64 (x) + 1.0) * 0.5;

        return SampleType (1.0 - bR, bR);
    }

    /** Convert gain to decibels and clamp results to greater than -100.0 dB */
    SampleType vgainTodB (SampleType x)
    {
        let b = vclamp (NOISE_FLOOR, INF32)::process(x);

        return SampleType (20.0) * log10 (b);
    }

    /** Convert decibels to gain and clamp inputs to greater than -100.0 dB */
    SampleType vdBtoGain (SampleType x)
    {
        let dB = vclamp (NOISE_FLOOR_DB, INF32)::process(x);

        return vpow (SampleType (10.0), dB * SampleType (1.0 / 20.0));
    }

    /** Return 1 if x is positive, -1 if negative, and 0 otherwise */
    SampleType vsgn (SampleType x)
    {
        return SampleType (x[0] > 0 ? 1 : -1, x[1] > 0 ? 1 : -1);
    }
    
    /** vsigmoidCD with a gain of 1 at the origin and drive (linear gain) of b, good for state saturation */
    SampleType vsigmoidCD_S (SampleType x, SampleType b)
    {
        return vsigmoidCD (b * x) * (ONE / b); 
    }

    /** An continuously differentiable algebraic sigmoid function. 

            f(x) = x / sqrt (x^2 + 1) 
    
        A cheap 'tanh' approximation
    */
    SampleType vsigmoidCD (SampleType x)
    {
        return x / sqrt (x * x + ONE);
    }

    /** Absolute value */
    SampleType vabs (SampleType x)
    {
        return SampleType (abs (x[0]), abs (x[1]));
    }

    /** Vector reduce max */
    SampleType.primitiveType vmaxR (SampleType x)
    {
        return max (x[0], x[1]);
    }

    /** Vector reduce min */
    SampleType.primitiveType vminR (SampleType x)
    {
        return min (x[0], x[1]);
    }

/*==============================================================================
Constants
==============================================================================*/
    
    //soul::filters
    using SampleType = float64<2>; //also used internally as 'CoeffType'
    let updateInterval = 128;
    namespace filt = soul::filters (SampleType, SampleType.primitiveType, updateInterval);

    //soul::oscillators
    namespace osc = soul::oscillators;
    
    //const SampleType
    let ADAA_TOL = SampleType (0.0000001);
    let ZERO = SampleType (0.0);
    let ONE = SampleType (1.0);
    let TWO = SampleType (2.0);
    let HALF = SampleType (0.5);

    //const float
    let INF32 = float (inf);
    let NOISE_FLOOR = 0.00001f;
    let NOISE_FLOOR_DB = -100.f;
    let SLEW_RATE_SECONDS_GAIN = 10.f;

    //const int
    let MAX_BUFFER_SIZE = 96000; //for arrays of SampleType
    let MAX_ARRAY_SIZE = 8; //for all other arrays
    let MAX_CUTOFF_HZ = 20000;
    let MIN_CUTOFF_HZ = 20;
} //namespace VA